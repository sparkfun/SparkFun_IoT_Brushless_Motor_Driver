{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>This is just a placeholder file for the webpage re-direct. All the content for this section is actually in the <code>getting_started.md</code> file.</p>"},{"location":"background/","title":"Background Information","text":"<p>Below, are several articles, application notes, and other technical resources on 3-phase motors and utilizing a field-oriented control (FOC) scheme:</p> <ul> <li>Microchip Technology<ul> <li>AN885: Brushless DC (BLDC) Motor Fundamentals</li> <li>AN2757: Sensored (Encoder-Based) Field-Oriented Control of Three-Phase Permanent Magnet Synchronous Motor (PMSM)</li> <li>AN1078: Sensorless Field-Oriented Control of a PMSM</li> <li>AVR32723: Sensor Field-Oriented Control for Brushless DC motors with AT32UC3B0256</li> </ul> </li> <li>Diodes Incorporated<ul> <li>AN1164: Introduction to Brushless DC Motors</li> </ul> </li> <li>Monolithic Power Systems<ul> <li>AN047: Brushless DC Motor Fundamentals</li> </ul> </li> <li>Texas Instruments<ul> <li>Demystifying BLDC motor commutation: Trap, Sine, &amp; FOC</li> <li>Sensored Field-Oriented Control of 3-Phase Permanent Magnet Synchronous Motors</li> <li>Sensorless Field-Oriented Control of 3-Phase Permanent Magnet Synchronous Motors</li> <li>Brushless-DC Motor Driver Considerations and Selection Guide</li> <li>High-Performance Brushless DC Motor Control</li> <li> Field-oriented control of permanent magnet synchronous motors</li> <li> Field-Oriented Control of Permanent Magnet Motors<ul> <li> Field-Oriented Control of Permanent Magnet Motors</li> </ul> </li> </ul> </li> <li>MATLAB<ul> <li> Motor Control, Part 4: Understanding Field-Oriented Control</li> </ul> </li> <li>Analog Devices + Trinamic<ul> <li>FOC As Hardware Building Block</li> </ul> </li> <li>Infineon Technologies<ul> <li>Motor Handbook</li> <li>AN204469 - FM3 Family 3-Phase PMSM FOC Control</li> <li>Block commutation vs. FOC in power tool motor control</li> <li> Motor control for BLDC: block commutation vs. field-oriented control</li> </ul> </li> <li>ST Microelectronics<ul> <li>AN5397: Current Sensing in Motion Control Applications</li> <li>AN4220: Sensorless Six-Step BLDC Commutation</li> </ul> </li> </ul>"},{"location":"example-BLDC/","title":"Example - Basic","text":"<p>In this example, users will be utilizing the TMC6300 motor driver to spin the motor.</p>"},{"location":"example-BLDC/#example-code","title":"Example Code","text":"<p>After installing and setting up the Arduino IDE and the Simple FOC Arduino library, users will need to upload the following example code using the SparkFun ESP32 Thing Plus C board definition. This code can be copied or downloaded below:</p> <p>  Download <code>BLDC.ino</code> Example Code </p> <p>Example Code</p> BLDC.ino<pre><code>    // Open loop motor control example\n    #include &lt;SimpleFOC.h&gt;\n\n\n    // BLDC motor &amp; driver instance\n    // BLDCMotor motor = BLDCMotor(pole pair number);\n    BLDCMotor motor = BLDCMotor(7);\n    // BLDCDriver3PWM driver = BLDCDriver3PWM(pwmA, pwmB, pwmC, Enable(optional));\n    BLDCDriver6PWM driver = BLDCDriver6PWM(5, 6, 9,10, 3, 11);\n\n    // Stepper motor &amp; driver instance\n    //StepperMotor motor = StepperMotor(50);\n    //StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6,  8);\n\n\n    //target variable\n    float target_velocity = 6;\n\n    // // instantiate the commander\n    Commander command = Commander(Serial);\n    // void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    // void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    void setup() {\n\n      // driver config\n      // power supply voltage [V]\n      driver.voltage_power_supply = 5;\n      // limit the maximal dc voltage the driver can set\n      // as a protection measure for the low-resistance motors\n      // this value is fixed on startup\n      driver.voltage_limit = 5;\n      // pwm frequency to be used [Hz]\n      // for atmega328 fixed to 32kHz\n      // esp32/stm32/teensy configurable\n      driver.pwm_frequency = 32000;\n\n\n      driver.init();\n      // link the motor and the driver\n      motor.linkDriver(&amp;driver);\n\n      // limiting motor movements\n      // limit the voltage to be set to the motor\n      // start very low for high resistance motors\n      // current = voltage / resistance, so try to be well under 1Amp\n      motor.voltage_limit = 3;   // [V]\n\n      // open loop control config\n      motor.controller = MotionControlType::velocity_openloop;\n\n      // init motor hardware\n      motor.init();\n\n      // add target command T\n      // command.add('T', doTarget, \"target velocity\");\n      // command.add('L', doLimit, \"voltage limit\");\n\n      Serial.begin(115200);\n      Serial.println(\"Motor ready!\");\n      Serial.println(\"Set target velocity [rad/s]\");\n      _delay(1000);\n\n    }\n\n    void loop() {\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n\n    }\n</code></pre>"},{"location":"example-BLDC/#running-the-motor","title":"Running the Motor","text":"<p>By default, the motor should spin automatically. However, if users wish to control the speed of the motor, they can uncomment lines 21-22 and 56-57 of code and reprogram the board.</p> Code Changes Highlighted <p>Uncomment the following lines of code (21-22 and 56-57):</p> BLDC.ino<pre><code>    // Open loop motor control example\n    #include &lt;SimpleFOC.h&gt;\n\n\n    // BLDC motor &amp; driver instance\n    // BLDCMotor motor = BLDCMotor(pole pair number);\n    BLDCMotor motor = BLDCMotor(7);\n    // BLDCDriver3PWM driver = BLDCDriver3PWM(pwmA, pwmB, pwmC, Enable(optional));\n    BLDCDriver6PWM driver = BLDCDriver6PWM(5, 6, 9,10, 3, 11);\n\n    // Stepper motor &amp; driver instance\n    //StepperMotor motor = StepperMotor(50);\n    //StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6,  8);\n\n\n    //target variable\n    float target_velocity = 6;\n\n    // // instantiate the commander\n    Commander command = Commander(Serial);\n    // void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    // void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    void setup() {\n\n      // driver config\n      // power supply voltage [V]\n      driver.voltage_power_supply = 5;\n      // limit the maximal dc voltage the driver can set\n      // as a protection measure for the low-resistance motors\n      // this value is fixed on startup\n      driver.voltage_limit = 5;\n      // pwm frequency to be used [Hz]\n      // for atmega328 fixed to 32kHz\n      // esp32/stm32/teensy configurable\n      driver.pwm_frequency = 32000;\n\n\n      driver.init();\n      // link the motor and the driver\n      motor.linkDriver(&amp;driver);\n\n      // limiting motor movements\n      // limit the voltage to be set to the motor\n      // start very low for high resistance motors\n      // current = voltage / resistance, so try to be well under 1Amp\n      motor.voltage_limit = 3;   // [V]\n\n      // open loop control config\n      motor.controller = MotionControlType::velocity_openloop;\n\n      // init motor hardware\n      motor.init();\n\n      // add target command T\n      // command.add('T', doTarget, \"target velocity\");\n      // command.add('L', doLimit, \"voltage limit\");\n\n      Serial.begin(115200);\n      Serial.println(\"Motor ready!\");\n      Serial.println(\"Set target velocity [rad/s]\");\n      _delay(1000);\n\n    }\n\n    void loop() {\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n\n    }\n</code></pre> <p>In order to drive the motor, users will need to access the serial monitor and provide the commands necessary to drive the motor. A full list of the available commands can be found in the Simple FOC Arduino library documentation. However, only the <code>T</code> and <code>L</code> commands are enabled in the example code.</p> <ul> <li>Sending a <code>T</code> command will set the target motor velocity in rads/s<ul> <li>Example - Entering <code>T6</code> into the serial monitor, will set the target motor velocity to 6 radians/s.</li> </ul> </li> <li>Sending a <code>L</code> command will set the voltage limit of the motor driver and in turn, the current limit (voltage_limit / motor_resistance)<ul> <li>Example - Entering <code>L5</code> into the serial monitor, will set the voltage limit to 5V and the current limit to .5A (5V/10\u03a9).</li> </ul> </li> </ul> <p>Baud Rate</p> <p>The serial monitor baud rate should be configured to <code>115200bps</code>.</p>"},{"location":"example-factory/","title":"Example - Factory Reset","text":"<p>This example, allows users to reprogram their board with the same sketch that it comes pre-programmed with from SparkFun.</p>"},{"location":"example-factory/#example-code","title":"Example Code","text":"<p>After installing and setting up the Arduino IDE and the Simple FOC Arduino library, users will need to upload the following example code using the SparkFun ESP32 Thing Plus C board definition. This code can be copied or downloaded below:</p> <p>  Download <code>IoT_MotorDriver.ino</code> Example Code </p> <p>Example Code</p> IoT_MotorDriver.ino<pre><code>    /******************************************************************************\n        IoT Motor Driver Example\n\n        Written By:\n            Madison Chodikov\n            Eric Orosel\n        Company: SparkFun Electronics   \n        Date: September 1 2023\n\n        This sketch is a stripped down version of the firmware that is preprogrammed\n        on the IoT Motor Driver. It is based on the open loop, velocity motor control\n        example from the SimpleFOC Arduino library.\n\n        This sketch will spin the motor based on the button inputs:\n            - Button 13: Starts/Stops the motor rotation\n            - Button 14: When spinning, switches the direction of rotation\n\n    ===============================================================================\n        Products:\n            IoT Brushless Motor Driver: https://www.sparkfun.com/products/22132\n\n        Repository:\n            https://github.com/sparkfun/SparkFun_IoT_Brushless_Motor_Driver\n    ===============================================================================\n\n        SparkFun code, firmware, and software is released under the MIT \n        License (http://opensource.org/licenses/MIT).\n\n        Distributed as-is; no warranty is given.\n    ******************************************************************************/\n\n    #include &lt;Wire.h&gt;\n    #include &lt;SimpleFOC.h&gt; //http://librarymanager/All#Simple%20FOC\n\n\n    //GPIO\n    #define auxBtn2   13\n    #define auxBtn1   14  \n\n    //driver\n    #define uh16      16\n    #define ul17      17\n    #define vh18      18\n    #define wh19      19\n    #define vl23      23\n    #define wl33      33\n    #define curSense  32\n\n    bool state = true;\n\n    //motor driver\n    BLDCMotor motor = BLDCMotor(7);\n    BLDCDriver6PWM driver = BLDCDriver6PWM(uh16, ul17, vh18, vl23, wh19, wl33,  curSense);\n    float target_velocity = 0.0;\n    Commander command = Commander(Serial);\n    void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    //////////////////////motor demo stuff///////////////////////////\n    struct Button{\n      const uint8_t PIN;\n      uint32_t numberKeyPresses;\n      bool pressed;\n    };\n    Button aux1 = {auxBtn1, 0, false};\n    Button aux2 = {auxBtn2, 0, false};\n\n    void IRAM_ATTR isr1(){\n      aux1.pressed = true;\n      target_velocity = target_velocity*(-1);\n      Serial.println(\"Changing directions.. \");\n    }\n\n    void IRAM_ATTR isr2(){\n      aux2.numberKeyPresses++;\n      aux2.pressed = true;\n\n      if((aux2.numberKeyPresses % 2) == 0)\n      {\n        target_velocity = 0;\n        Serial.println(\"Stopping motor.. \");\n      }\n      else\n      {\n        target_velocity = 5;\n        motor.enable();\n        Serial.println(\"Starting motor.. \");\n      }\n    }\n\n\n    void setup() {\n\n      //motor demo stuff\n      driver.voltage_power_supply = 3.3;\n      driver.pwm_frequency = 20000;\n      driver.voltage_limit = 4;\n      driver.init();\n      motor.linkDriver(&amp;driver);\n      motor.voltage_limit = 4;\n      motor.controller = MotionControlType::velocity_openloop;\n      motor.init();\n      motor.disable();\n      pinMode(aux1.PIN, INPUT_PULLUP); // Sets pin 14 on the ESP32 as an interrupt\n      attachInterrupt(aux1.PIN, isr1, FALLING); // Triggers when aux1 is pulled to GND (button pressed)\n      pinMode(aux2.PIN, INPUT_PULLUP); // Sets pin 13 on the ESP32 as an interrupt\n      attachInterrupt(aux2.PIN, isr2, FALLING); // Triggers when aux2 is pulled to GND (button pressed)\n      delay(100);\n\n      Serial.begin(115200);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    void loop() { \n\n      // Button Press ISR\n      if(aux1.pressed){ \n        aux1.pressed = false;\n      }\n\n      // Turning motor on and off\n      if(aux2.pressed){ \n        aux2.pressed = false;\n      }\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      // Basic motor movement\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n      delay(5);\n    }\n</code></pre>"},{"location":"example-factory/#running-the-motor","title":"Running the Motor","text":"<p>By default, the motor should be disabled and spin freely. Users can utilize the user buttons 13 and 14 to control the motor.</p> <ul> <li>13 - Starts and stops the motor spin</li> <li>14 - Reverses the direction of the motor's rotation, when it is spinning</li> </ul> <p>Motor Overheating</p> <p>When the motor is stopped, the motor driver is still enabled. Therefore, current is still running through the stator coils and holding the motor in place. After a few minutes, users may notice that the motor begins to heat up a bit.</p> <p>If this becomes an issue, users can modify their code to disable the motor driver when the motor stops. This will prevent the motor from heating up, but the motor will spin freely as the motor driver is no longer engaged.</p> Modification <p>Modify the sketch and insert <code>motor.disable();</code> between lines <code>80</code> - <code>81</code>.</p> DC.ino<pre><code>    /******************************************************************************\n        IoT Motor Driver Example\n\n        Written By:\n            Madison Chodikov\n            Eric Orosel\n        Company: SparkFun Electronics   \n        Date: September 1 2023\n\n        This sketch is a stripped down version of the firmware that is preprogrammed\n        on the IoT Motor Driver. It is based on the open loop, velocity motor control\n        example from the SimpleFOC Arduino library.\n\n        This sketch will spin the motor based on the button inputs:\n            - Button 13: Starts/Stops the motor rotation\n            - Button 14: When spinning, switches the direction of rotation\n\n    ===============================================================================\n        Products:\n            IoT Brushless Motor Driver: https://www.sparkfun.com/products/22132\n\n        Repository:\n            https://github.com/sparkfun/SparkFun_IoT_Brushless_Motor_Driver\n    ===============================================================================\n\n        SparkFun code, firmware, and software is released under the MIT \n        License (http://opensource.org/licenses/MIT).\n\n        Distributed as-is; no warranty is given.\n    ******************************************************************************/\n\n    #include &lt;Wire.h&gt;\n    #include &lt;SimpleFOC.h&gt; //http://librarymanager/All#Simple%20FOC\n\n\n    //GPIO\n    #define auxBtn2   13\n    #define auxBtn1   14  \n\n    //driver\n    #define uh16      16\n    #define ul17      17\n    #define vh18      18\n    #define wh19      19\n    #define vl23      23\n    #define wl33      33\n    #define curSense  32\n\n    bool state = true;\n\n    //motor driver\n    BLDCMotor motor = BLDCMotor(7);\n    BLDCDriver6PWM driver = BLDCDriver6PWM(uh16, ul17, vh18, vl23, wh19, wl33,  curSense);\n    float target_velocity = 0.0;\n    Commander command = Commander(Serial);\n    void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    //////////////////////motor demo stuff///////////////////////////\n    struct Button{\n      const uint8_t PIN;\n      uint32_t numberKeyPresses;\n      bool pressed;\n    };\n    Button aux1 = {auxBtn1, 0, false};\n    Button aux2 = {auxBtn2, 0, false};\n\n    void IRAM_ATTR isr1(){\n      aux1.pressed = true;\n      target_velocity = target_velocity*(-1);\n      Serial.println(\"Changing directions.. \");\n    }\n\n    void IRAM_ATTR isr2(){\n      aux2.numberKeyPresses++;\n      aux2.pressed = true;\n\n      if((aux2.numberKeyPresses % 2) == 0)\n      {\n        target_velocity = 0;\n        Serial.println(\"Stopping motor.. \");\n      }\n      else\n      {\n        target_velocity = 5;\n        motor.enable();\n        Serial.println(\"Starting motor.. \");\n      }\n    }\n\n\n    void setup() {\n\n      //motor demo stuff\n      driver.voltage_power_supply = 3.3;\n      driver.pwm_frequency = 20000;\n      driver.voltage_limit = 4;\n      driver.init();\n      motor.linkDriver(&amp;driver);\n      motor.voltage_limit = 4;\n      motor.controller = MotionControlType::velocity_openloop;\n      motor.init();\n      motor.disable();\n      pinMode(aux1.PIN, INPUT_PULLUP); // Sets pin 14 on the ESP32 as an interrupt\n      attachInterrupt(aux1.PIN, isr1, FALLING); // Triggers when aux1 is pulled to GND (button pressed)\n      pinMode(aux2.PIN, INPUT_PULLUP); // Sets pin 13 on the ESP32 as an interrupt\n      attachInterrupt(aux2.PIN, isr2, FALLING); // Triggers when aux2 is pulled to GND (button pressed)\n      delay(100);\n\n      Serial.begin(115200);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    void loop() { \n\n      // Button Press ISR\n      if(aux1.pressed){ \n        aux1.pressed = false;\n      }\n\n      // Turning motor on and off\n      if(aux2.pressed){ \n        aux2.pressed = false;\n      }\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      // Basic motor movement\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n      delay(5);\n    }\n</code></pre>"},{"location":"hardware_assembly/","title":"Hardware Assembly","text":""},{"location":"hardware_assembly/#usb-programming","title":"USB Programming","text":"<p>The USB connection is utilized for programming and serial communication. Users only need to plug their IoT Motor Driver into a computer using a USB-C cable.</p> <p></p> <p>The IoT Motor Driver with USB-C cable attached.</p>"},{"location":"hardware_assembly/#headers","title":"Headers","text":"New to soldering? <p>If you have never soldered before or need a quick refresher, check out our How to Solder: Through-Hole Soldering guide.</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <p>The pins for the IoT Motor Driver are broken out into 0.1\"-spaced pins on the outer edges of the board. When selecting headers, be sure you are aware of the functionality you require.</p> <p></p> <p>Soldering headers to the IoT Motor Driver.</p>"},{"location":"hardware_assembly/#qwiic-devices","title":"Qwiic Devices","text":"<p>The Qwiic system allows users to effortlessly prototype with a Qwiic compatible I<sup>2</sup>C device without soldering. Users can attach any Qwiic compatible sensor or board, with just a Qwiic cable. (*The example below, is for demonstration purposes and is not pertinent to the board functionality or this tutorial.)</p> <p></p> <p>The BME688 environmental and VL53L1X distance Qwiic sensor boards connected to the IoT Motor Driver.</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":""},{"location":"hardware_overview/#board-dimensions","title":"Board Dimensions","text":"<p>The board dimensions are illustrated in the drawing below; the listed measurements are in inches.</p> <p></p> <p>Board dimensions (PDF) for the IoT Motor Driver board, in inches.</p> Need more measurements? <p>For more information about the board's dimensions, users can download the eagle files for the board. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> </p>"},{"location":"hardware_overview/#usb-c-connector","title":"USB-C Connector","text":"<p>The USB connector is provided to power and program the board. For most users, it will be the primary programming interface for the ESP32 module on the IoT Motor Driver board.</p> <p></p> <p>USB-C connector on the IoT Motor Driver board.</p>"},{"location":"hardware_overview/#power","title":"Power","text":"<p>The IoT Motor Driver only requires 5V to power all of the board's components. The simplest method to power the board is through the USB-C connector. Alternatively, the <code>3V3</code> pin can be used to supply power to any of the components, except the motor driver.</p> <p></p> <p>IoT Motor Driver power connections.</p> <p>Below, is a general summary of the power circuitry on the board:</p> <ul> <li><code>3V3</code> - Provides a regulated 3.3V from the USB (5V) power to the board, excluding the TMC6300 motor driver.<ul> <li>Used to power the ESP32-WROOM module, hall-effect and current sensors, CH340C Serial-to-UART bridge, Qwiic connector, and the WS2812 RGB LED.</li> <li>The 3.3V AP2112 LDO regulator can source up to 600mA.</li> <li>Broken out as PTH pin.</li> </ul> </li> <li><code>3V3_A</code> - Provides a regulated 3.3V from the USB (5V) power to only the TMC6300 motor driver.<ul> <li>The motor driver will not function without power from the USB connector.</li> <li>The 3.3V AP63357 LDO regulator can source up to 3.5A.</li> </ul> </li> <li><code>VUSB</code> - The voltage from the USB-C connector, usually 5V.<ul> <li>Power source for the entire board.<ul> <li>Powers the two 3.3V voltage regulators (AP2112 and AP63357).</li> </ul> </li> <li>Features reverse current protection and a thermal fuse.</li> <li><code>MEAS</code> - These pins can be used to measure the current being drawn through the USB connector (see the Jumpers section).</li> </ul> </li> <li><code>GND</code> - The common ground or the 0V reference for the voltage supplies.</li> <li>Qwiic Connector - Provides a regulated 3.3V voltage to the Qwiic devices.</li> </ul> <p>Info</p> <p>For more details, users can reference the schematic and the datasheets of the individual components on the board.</p> Motor Voltage <p>The Gimbal Stabilizer Motor has an operating voltage range of 6 - 8V. However, we have found that it still functions properly with only 3.3V provided by the IoT Motor Driver board.</p>"},{"location":"hardware_overview/#ch340-serial-to-uart","title":"CH340 Serial-to-UART","text":"<p>The CH340 allows the ESP32-WROOM to communicate with a computer/host device through the board's USB-C connection. This allows the board to show up as a device on the serial (or COM) port of the computer. Users will need to install the latest drivers for the computer to recognize the board (see Software Overview section).</p>"},{"location":"hardware_overview/#microcontroller-esp32-wroom","title":"Microcontroller - ESP32-WROOM","text":"<p>The brains of the IoT Motor Driver, is an ESP32-WROOM module with 16MB of flash memory. Espressif's ESP32-WROOM module is a versatile, WiFi+BT+BLE MCU module that targets a wide variety of applications. At the core of this module is the ESP32-D0WDQ6 system on a chip (SoC) which is designed to be both scalable and adaptive microcontroller. Its laundry list of features include:</p> <ul> <li> <p>Features:</p> <ul> <li>Xtensa\u00ae Dual-Core 32-bit LX6 Microprocessor (up to 240MHz)<ul> <li>448KB ROM and 520KB SRAM</li> <li>16MB of Embedded SPI Flash Storage</li> </ul> </li> <li>Cryptographic Hardware Accelerators<ul> <li>AES, SHA2, ECC, RSA-4096</li> </ul> </li> <li>Integrated 802.11 b/g/n WiFi 2.4GHz Transceiver (up to 150Mbps)</li> <li>Integrated dual-mode Bluetooth (Bluetooth v4.2 and BLE)</li> <li>26 GPIO (including strapping pins)<ul> <li>8x Capacitive Touch Electrodes</li> </ul> </li> <li>Operating Voltage: 3.0 to 3.6V<ul> <li>WiFi: 380mA (peak)</li> <li>Light-Sleep: 800\u00b5A</li> <li>Deep-Sleep: 10 - 150\u00b5A</li> </ul> </li> </ul> </li> <li> <p> ESP32-WROOM module on the IoT Motor Driver. </p> </li> </ul> <p>Warning</p> <p>Users should be aware of the following nuances and details of this board</p> <ul> <li>The ESP32-WROOM is only compatible with 2.4GHz WiFi networks; it will not work on the 5GHz bands.</li> <li>For details on the boot mode configuration, please refer to section 3.3 Strapping Pins of the ESP32-WROOM module datasheet.</li> </ul> <p>Info</p> <p>The ESP32-WROOM module has various power modes:</p> <ul> <li>Active - The chip radio is powered on. The chip can receive, transmit, or listen.</li> <li>Modem Sleep - The CPU is operational and the clock is configurable. The Wi-Fi/Bluetooth baseband and radio are disabled.</li> <li>Light Sleep - The CPU is paused. The RTC memory and RTC peripherals, as well as the ULP coprocessor are running.</li> <li>Deep Sleep - Only the RTC memory and RTC peripherals are powered on. The ULP coprocessor is functional.</li> <li>Hibernation - Only one RTC timer on the slow clock and certain RTC GPIOs are active.</li> <li>Off - Chip is powered off</li> </ul> <p>For more information on the power management of the ESP32-WROOM module, pleaser refer to Section 3.7 and Tables: 8 and 17 of the ESP32 SoC Datasheet.</p>"},{"location":"hardware_overview/#debugging","title":"Debugging","text":"<p>For users interested in debugging their code, the JTAG pins are broken out on the board. However, the debugging feature is only available through the ESP-IDF.</p> <ul> <li><code>TMS</code>: <code>GPIO 14</code></li> <li><code>TDI</code>: <code>GPIO 12</code></li> <li><code>TCK</code>: <code>GPIO 13</code></li> <li><code>TDO</code>: <code>GPIO 15</code></li> </ul> <p></p> <p>The JTAG pins of the ESP32-WROOM module on the IoT Motor Driver.</p>"},{"location":"hardware_overview/#firmware-download-mode","title":"Firmware Download Mode","text":"<p>Users can manually force the board into the serial bootloader with the BOOT button. Please, refer to the Boot Button section below for more information.</p>"},{"location":"hardware_overview/#peripherals-and-io","title":"Peripherals and I/O","text":"<p>Warning</p> <p>Users should be aware of the following nuances of this board</p> <ul> <li>\u26a1 All the GPIO on the IoT Motor Driver are 3.3V pins.<ul> <li>The I/O pins are not 5V-tolerant! To interface with higher voltage components, a logic level adapter is recommended.</li> </ul> </li> <li>\u26a1 There are electrical limitations to the amount of current that the ESP32-WROOM module can sink or source. For more details, check out the ESP32-WROOM module datasheet.</li> <li>There are some limitations to the ADC performance, see the Note from the ADC Characteristics section of the ESP32 SoC datasheet.</li> </ul> <p>The ESP32-WROOM module has 26 multifunctional GPIO, of which, 16 I/O pins are used to interface with motor driver, sensors, and status LED on the board. Additionally, 13 I/O pins are broken out to PTH pins and the users buttons. All of the IoT Motor Driver pins have a .1\" pitch spacing for headers.</p> <p>While all of the GPIO pins are capable of functioning as digital I/O pins, various pins can have additional capabilities with the pin multiplexing feature of the ESP32 SoC. For more technical specifications on the I/O pins, please refer to the ESP32 SoC datasheet.</p> <ul> <li>13x 12-bit analog to digital converter (ADC) channels</li> <li>3x UARTs (only two are configured by default in the Arduino IDE, one UART is used for bootloading/debug)</li> <li>3x SPI (only one is configured by default in the Arduino IDE)</li> <li>2x I<sup>2</sup>C (only one is configured by default in the Arduino IDE)</li> <li>2x I<sup>2</sup>S Audio</li> <li>2x digital-to-analog converter (DAC) channels</li> <li>16x 20-bit PWM outputs</li> <li>8x Capacitive Touch Inputs</li> </ul> <p>Info</p> <p>Users should be aware of the following limitations for the board in the Arduino IDE.</p> <ul> <li>Not all of the features, listed above, are available in the Arduino IDE. For the full capabilities of the ESP32, the Espressif IDF should be utilized.<ul> <li>Only one I<sup>2</sup>C bus is defined.</li> <li>Only two UART interfaces are available.<ul> <li>UART (USB): <code>Serial</code></li> <li><code>RX</code>/<code>TX</code> Pins: <code>Serial1</code></li> </ul> </li> <li>Only one SPI bus is defined.</li> </ul> </li> </ul>"},{"location":"hardware_overview/#peripheral-devices","title":"Peripheral Devices","text":"<p>This development board features several components operating together to create an IoT device. Their connections are shown in the diagram below and their operations are listed in the boxes below. For more details on each component, please refer to the sections below.</p> <p></p> <p>Block diagram of the IoT Motor Driver board's peripherals.</p> <ul> <li> <p>Inputs</p> <ul> <li>TMC6300 Motor Driver<ul> <li>Diagnostic Pin</li> </ul> </li> <li>TMAG5273 Hall-Effect Sensor</li> <li>INA240 Current-Sense Amplifier</li> <li>MCP6021 Operational Amplifier</li> <li>User Buttons</li> </ul> </li> <li> <p>Outputs</p> <ul> <li>TMC6300 Motor Driver<ul> <li>Half-Bridge Pins</li> <li>Standby Pin</li> </ul> </li> <li>RGB Status LED</li> </ul> </li> </ul>"},{"location":"hardware_overview/#pin-functionality","title":"Pin Functionality","text":"<p>There are several pins that have special functionality in addition to general digital I/O. These pins and their additional functions are listed in the tabs below. For more technical specifications on the I/O pins, you can refer to the schematic, ESP32-WROOM module datasheet, ESP32 SoC datasheet, and documentation for the ESP32 Arduino core.</p> Digital I/O PinsAnalog InputsPWM &amp; Analog (DAC) OutputsSerial PinsSPI PinsI<sup>2</sup>C Pins <p>Any GPIO pin on the ESP32-WROOM module can function as a digital I/O (input or output). However, users will need to declare the <code>pinMode()</code> (link) in the setup of their sketch (programs written in the Arduino IDE) to configure a pin as an input or an output.</p> <ul> <li> <p>Inputs</p> <p>When configured properly, an input pin will be looking for a HIGH or LOW state. Input pins are High Impedance and takes very little current to move the input pin from one state to another.</p> <p> <code>DIAG</code> (TMC6300) <code>GPIO 34</code> <code>INT</code> (TMAG5273) <code>GPIO 04</code> Button 13 <code>GPIO 13</code> Button 14 <code>GPIO 14</code> <p></p> <li> <p>Outputs</p> <p>When configured as an output the pin will be at a HIGH or LOW voltage. Output pins are Low Impedance: This means that they can provide a relatively substantial amount of current to other circuits.</p> <p> <code>VIO</code> (TMC6300) <code>GPIO 05</code> WS2812 <code>GPIO 02</code> <p></p> <p>Warning</p> <p>\u26a1 There are electrical limitations to the amount of current that the ESP32-WROOM module can sink or source. For more details, check out the ESP32-WROOM module datasheet.</p> <p>Tip</p> <p>Pins cannot be configured to operate simultaneously as an input and output, without implementing the pin as an interrupt.</p> <p>The ESP32-WROOM module provides a 12-bit ADC input on thirteen of its I/O pins. This functionality is accessed in the Arduino IDE using the <code>analogRead(pin)</code> function. (The available ADC pins are highlighted in the image below.)</p> <p> Current Sensor INA240 (<code>U</code>) INA240 (<code>V</code>) INA240 (<code>W</code>) MCP6021 Analog Input <code>GPIO 35</code> <code>GPIO 36</code> <code>GPIO 39</code> <code>GPIO 32</code> <p></p> <p>Info</p> <p>By default, in the Arduino IDE, <code>analogRead()</code> returns a 10-bit value. To change the resolution of the value returned by the <code>analogRead()</code> function, use the <code>analogReadResolution(bits)</code> function.</p> <p>Tip</p> <p>To learn more about analog vs. digital signals, check out this great tutorial.</p> <ul> <li> <p> <p>Analog vs. Digital</p> <p>The ESP32-WROOM module supports up to sixteen channels of 20-bit PWM (Pulse Width Modulation) outputs on any of its I/O pins. This is accessed in the Arduino IDE using the <code>analogWrite(pin, value)</code> function. (Any I/O pin can be used for the PWM outputs; the available DAC pins, with true analog outputs, are highlighted in the image below.)</p> <p></p> <p> Motor Driver <code>UH</code> <code>UL</code> <code>VH</code> <code>VL</code> <code>WH</code> <code>WL</code> PWM Output <code>GPIO 16</code> <code>GPIO 17</code> <code>GPIO 18</code> <code>GPIO 23</code> <code>GPIO 19</code> <code>GPIO 33</code> <p></p> <p>Info</p> <p>By default, in the Arduino IDE, <code>analogWrite()</code> accepts an 8-bit value. To change the resolution of the PWM signal for the <code>analogWrite()</code> function, use the <code>analogWriteResolution(bits)</code> function. (The PWM output is not a true analog signal.)</p> <p>Tip</p> <p>To learn more about pulse width modulation (PWM), check out this great tutorial.</p> <ul> <li> <p> <p>Pulse Width Modulation</p> <p>The ESP32-WROOM module provides three UART ports. By default, the UART port for the USB connection (<code>Serial</code>) and the labeled UART I/O pins on the board (<code>Serial1</code>) can be accessed through the Arduino IDE using the serial communication class.</p> <p>Info</p> <p>By default, in the Arduino IDE, the  board definition supports:      <ul> <li><code>Serial</code> - UART (USB)</li> <li><code>Serial1</code> - Pins: <code>RX</code>/<code>TX</code> (<code>GPIO 16</code>/<code>GPIO 17</code>)</li> </ul> Note <ul> <li>The <code>GPIO 16</code> and <code>GPIO 17</code> pins of <code>Serial1</code> are already dedicated to the <code>UH</code>/<code>UL</code> half-bridge on the TMC63000 motor driver and are not broken out for users to access.</li> <li>In order to utilize the serial communication on the strapping pins, users will need to create a custom serial port object and declare which pins to access.</li> </ul> <p>Tip</p> <p>To learn more about serial communication, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Communication</p> <p>Tip</p> <p>We have noticed that with the ESP32 Arduino core, <code>Serial.available()</code> does not operate instantaneously. This is due to an interrupt triggered by the UART, to empty the FIFO when the <code>RX</code> pin is inactive for two byte periods:</p> <ul> <li>At 9600 baud, <code>hwAvailable</code> takes [<code>number of bytes received</code> + 2] x 1 ms = 11 ms before the UART indicates that data was received from: <code>\\r\\nERROR\\r\\n</code>.</li> <li>At 115200 baud, <code>hwAvailable</code> takes [<code>number of bytes received</code> + 2] x .087 ms = ~1 ms before the UART indicates that data was received from: <code>\\r\\nERROR\\r\\n</code>.</li> </ul> <p>For more information, please refer to this chatroom discussion.</p> <p>The ESP32-WROOM module provides three SPI buses. By default, in the Arduino IDE, the SPI class is configured to utilize pins <code>GPIO 18</code> (SCK), <code>GPIO 19</code> (POCI), <code>GPIO 23</code> (PICO). In order to utilize the other SPI ports or objects, users will need to create a custom SPI object and declare which pins to access.</p> <p>Info</p> <p>To comply with the latest OSHW design practices, we have adopted the new SPI signal nomenclature (SDO/SDI and PICO/POCI). The terms Master and Slave are now referred to as Controller and Peripheral. The <code>MOSI</code> signal on a controller has been replaced with <code>SDO</code> or <code>PICO</code>. Please refer to this announcement on the decision to deprecate the MOSI/MISO terminology and transition to the SDO/SDI naming convention.</p> <p> SCK <code>GPIO 18</code> (<code>SCK</code>) SDI or POCI <code>GPIO 19</code> (<code>MISO</code>) SDO or PICO <code>GPIO 23</code> (<code>MOSI</code>) CS <code>GPIO 5</code> (<code>SS</code>) <p></p> Note <ul> <li>The <code>GPIO 18</code>,<code>GPIO 19</code>, and <code>GPIO 23</code> pins of the <code>SPI</code> bus are already dedicated to the <code>VH</code>/<code>WH</code>/<code>VL</code> MOSFETs on the TMC63000 motor driver and are not broken out for users to access.</li> <li>The <code>CS</code> pin associated with <code>GPIO 05</code> is also already dedicated to the <code>STBY</code> pin of the TMC63000 motor driver and is not broken out for users to access.</li> </ul> <p>Tip</p> <p>To learn more about the serial peripheral interface (SPI) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Peripheral Interface (SPI)</p> <p>The ESP32-WROOM module module can support up to two I<sup>2</sup>C buses. By default, in the Arduino IDE, the Wire class is configured to utilize pins <code>GPIO 21</code> (SDA) and <code>GPIO 22</code> (SCL). These pins share the same I<sup>2</sup>C bus with the Qwiic connector and TMAG5273 hall-effect sensor. In order to utilize the other I<sup>2</sup>C ports, users will need to create a custom Wire object and declare which pins to access.</p> <ul> <li> <p> <p>I<sup>2</sup>C Pins</p> SCL <code>GPIO 22</code> SDA <code>GPIO 21</code> <p></p> <p>TMAG5273 I<sup>2</sup>C Address:</p> <ul> <li>0x35 (Default) (7-bit)</li> <li>0x6A (write)/0x6B (read)</li> </ul> <li> <p> Default I<sup>2</sup>C bus connections for the IoT Motor Driver. </p> </li> <p>Tip</p> <p>To learn more about the inter-integrated circuit (I<sup>2</sup>C) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>Inter-Integrated Circuit (I<sup>2</sup>C)</p>"},{"location":"hardware_overview/#motor-driver-tmc6300","title":"Motor Driver - TMC6300","text":"<p>The TMC6300 from Trinamic Motion Control, part of Analog Devices, is a low voltage, 3-Phase BLDC/PMSM motor driver utilizing separate high-side and low-side control signals for its three half-bridges.</p> <ul> <li> <p>Features:</p> <ul> <li>VIN: 2.0V to 11.0V<ul> <li>Operating current: 7mA</li> <li>Standby current: 30nA</li> </ul> </li> <li>VOUT: 1.8V</li> <li>3 Half-Bridges<ul> <li>3 High-side MOSFETs</li> <li>3 Low-side MOSFETs</li> </ul> </li> <li>I/O Supply Voltage Input</li> <li>Diagnostic Output</li> <li>Overtemperature Protection<ul> <li>Shutdown Temperature: 150\u00b0C</li> <li>Typical Power Dissipation: 1W</li> </ul> </li> <li>Short Protection</li> </ul> <p>Info</p> <p>For more details, please refer to the TMC6300 datasheet.</p> </li> <li> <p> TMC6300 chip on the IoT Motor Driver. </p> <p>For users unfamiliar with the TMC6300 motor driver, please check out our hookup guide below.</p> <ul> <li> <p> <p>TMC6300 BLDC Motor Driver Hookup Guide</p>"},{"location":"hardware_overview/#half-bridges","title":"Half-Bridges","text":"<p>The TMC6300 features high-side and low-side MOSFET pairs of the three available half-bridges which control the commutation of the three motor phases.</p> <p></p> <p>6 PWM control of a 3-phase motor commutation. (Source: Modified from the Block commutation vs. FOC in power tool motor control application note)</p> InputOutput <p>The electronic commutation sequence for these MOSFETs will depend on the motor that is connected. For most cases, users will provide a PWM signal to each of these pins. These are active-high pins.</p> <p> ESP32-WROOM <code>16</code> <code>17</code> <code>18</code> <code>23</code> <code>19</code> <code>33</code> Motor Driver <code>UH</code> <code>UL</code> <code>VH</code> <code>VL</code> <code>WH</code> <code>WL</code> <p></p> Active High <p>By pulling the pin high, the MOSFET will enable power to flow through that section of the half-bridge.</p> <p>With the electronic commutation sequence provided to the half-bridges, the output motor phases will drive a connected motor.</p> <p>  The three motor phase outputs (<code>U</code>/<code>V</code>/<code>W</code>) from the TMC6300 are used to drive the gimbal motor, attached through the JST connector.  </p>"},{"location":"hardware_overview/#motor-commutation","title":"Motor Commutation","text":"<p>The TMC6300 relies on an electrical commutation sequence/signal to drive the motor phases to a BLDC or PMSM motor. The commutation signals for these motors are trapezoidal for BLDC motors and sinusoidal for PMSM motors.</p> <ul> <li> <p>      Trapezoidal motor commutation.      </p> </li> <li> <p>      Sinusoidal motor commutation.      </p> </li> </ul> <p> (Source: Brushless-DC Motor Driver Considerations and Selection Guide application note) </p> <p>Gimbal Motor</p> <p>Based on measuring the output from one of the coils, our gimbal motor is a PMSM and would require a sinusoidal waveform to drive the motor. It should be noted that a trapezodial waveform can probably be used; however, users may notice effects such as cogging.</p> <p>  Sinusoidal PWM signal. (Source: Demystifying BLDC motor commutation: Trap, Sine, &amp; FOC)  </p> <p>For a trapezoidal signal, the high-side (HS) and low-side (LS) MOSFETs, can just be driven high or low. However, in order to approximate a sinusoidal signal, a progressively varying PWM signal must be provided with all six signals in sync with each other.</p>"},{"location":"hardware_overview/#viostandby-pin","title":"<code>VIO</code>/Standby Pin","text":"<p>In it's default configuration, the <code>VIO</code> pin is used to enable the motor driver and set the logic level voltage of the TMC6300 inputs. However, the <code>VIO</code> pin also operates as a standby pin when it is pulled <code>LOW</code>. In standby, the TMC6300 resets and sits in standby mode.</p> <p>Users can control the <code>VIO</code> pin with <code>GPIO 05</code> on the ESP32-WROOM module, to reset the TMC6300 or put it in standby mode.</p>"},{"location":"hardware_overview/#diagnostic-pin","title":"Diagnostic Pin","text":"<p>The diagnostic pin is triggered based on different faults (i.e. shorts and overtemperature) detected by the IC. By default, the status will be indicated by the, green diagnostic, <code>DIAG</code> LED and will remail <code>LOW</code> until triggered. Once triggered, users will need to disable and reset the TMC6300 or power cycle the board.</p> <p>Users can monitor the diagnostic pin with <code>GPIO 34</code> on the ESP32-WROOM module, to determine if the TMC6300 need to be reset to clear a fault.</p>"},{"location":"hardware_overview/#current-sense-pin","title":"Current Sense Pin","text":"<p>The current sense pin is the foot point of the <code>U</code> and <code>V</code> half-bridges, with a 0.12\u03a9 resistor attached. Users can measure the voltage across the resistor to determine the current flowing to the motor (see the Low-side Op Amp - MCP6021 section below).</p>"},{"location":"hardware_overview/#hall-effect-sensor-tmag5273","title":"Hall-Effect Sensor - TMAG5273","text":"<p>The TMAG5273 from Texas Instruments, is a 3-axis hall-effect sensor utilizing a 12-bit ADC. For more information, please refer to the TMAG5273 datasheet.</p> <ul> <li> <p>Features:</p> <ul> <li>I<sup>2</sup>C Address:<ul> <li>0x35 (Default) (7-bit)</li> <li>0x6A (write)/0x6B (read)</li> </ul> </li> <li>Magnetic Range (Sensitivity):<ul> <li>\u00b1 40mT (820 LSB/mT)</li> <li>\u00b1 80mT (410 LSB/mT)</li> </ul> </li> <li>Magnetic Drift: 5%</li> <li>Rotational Accuracy: \u00b1 0.5\u00b0/360\u00b0 rotation</li> <li>Voltage Range: 1.7 - 3.6V<ul> <li>Sleep: 5nA</li> <li>Wake-Up/Sleep: 1\u00b5A</li> <li>Active: 2.3mA</li> </ul> </li> <li>Operating Temperature: \u201340 - 125\u00b0C</li> <li>Integrated temperature compensation</li> <li>Configurable sample rate</li> </ul> </li> <li> <p> The TMAG5273 hall-effect sensor on the IoT Motor Driver. </p> <p>Magnetic Axes</p> <p>On the IoT Motor Driver, users will primarily be interested in magnetic field of the X-Y axes to measure the position of the gimbal motor.</p> <p> The magnetic axes of TMAG5273 hall-effect sensor. </p> </li> </ul> <p>Info</p> <p>For more details, please refer to the TMAG5273 datasheet.</p>"},{"location":"hardware_overview/#interrupt-pin","title":"Interrupt Pin","text":"<p>The interrupt pin of the TMAG5723 can be configured in different modes to utilize either the <code>INT</code> or <code>SCL</code> pins.</p> <ul> <li>No interrupt</li> <li>Interrupt through <code>INT</code></li> <li>Interrupt through <code>INT</code> except when I2C busy</li> <li>Interrupt through <code>SCL</code></li> <li>Interrupt through <code>SCL</code> except when I2C busy</li> </ul> <p>Tip</p> <p>We recommend utilizing the default <code>INT</code> pin to trigger interrupts; as it is already connected to <code>GPIO 04</code> of the ESP32-WROOM module.</p> Bus Contention <p>Texas Instruments does not recommend sharing the I<sup>2</sup>C bus with multiple devices when using the <code>SCL</code> pin for the interrupt function. The <code>SCL</code> interrupt can potentially corrupt the transactions with other devices, when present on the same I<sup>2</sup>C bus.</p> <p>Note</p> <p>The TMAG5273 is programmed to detect a magnetic threshold in wake-up or sleep mode. Once the magnetic threshold cross is detected, the device asserts a latched interrupt signal through the INT pin, and goes back to stand-by mode. The interrupt latch is cleared through the <code>SCL</code> pin.</p>"},{"location":"hardware_overview/#current-sensors","title":"Current Sensors","text":"<p>There are two different types of Op Amps on the board to amplify the input voltage for the current measurements.</p> <ul> <li>The INA240 is used for the in-line current measurements between the TMC6300 and the gimabal motor.</li> <li>The MCP6021 is used on the low-side current measurement of the TMC63000's half-bridges.</li> </ul> <p> Current Sensor INA240 (<code>U</code>) INA240 (<code>V</code>) INA240 (<code>W</code>) MCP6021 Analog Input <code>GPIO 35</code> <code>GPIO 36</code> <code>GPIO 39</code> <code>GPIO 32</code> <p></p>"},{"location":"hardware_overview/#inline-ina240","title":"Inline - INA240","text":"<p>The INA240 from Texas Instruments, is a voltage-output, current-sense amplifier. For more information, please refer to the INA240 datasheet.</p> <ul> <li> <p> The INA240 current-sense amplifier on the IoT Motor Driver. </p> </li> <li> <p> Configured Gain 20 &amp;PlusMn;0.2% Bandwidth 100kHz Voltage Range Range: 2.7 - 5.5V Quiescent Current 1.8 - 2.6mA Operating Temperature \u201340 - 125\u00b0C </p> </li> </ul>"},{"location":"hardware_overview/#low-side-op-amp-mcp6021","title":"Low-side Op Amp - MCP6021","text":"<p>The MCP6021 from Microchip Technology, Inc., is a rail-to-rail input and output operational amplifier. The chip . For more information, please refer to the MCP6021 datasheet.</p> <ul> <li> <p> The MCP6021 Op Amp on the IoT Motor Driver. </p> </li> <li> <p> Configured Gain 21 Bandwidth 10MHz Voltage Range Range: 2.5 - 5.5V Quiescent Current 0.5 - 1.35mA Operating Temperature \u201340 - 125\u00b0C </p> </li> </ul>"},{"location":"hardware_overview/#status-leds","title":"Status LEDs","text":"<p>There are five status LEDs on the TMC6300 motor driver:</p> <ul> <li><code>PWR</code> - Power (Red)<ul> <li>Turns on once power is supplied through the USB-C connector</li> </ul> </li> <li><code>MPWR</code> - Power (Red)<ul> <li>Turns on once power is supplied through the USB-C connector</li> </ul> </li> <li><code>DIAG</code> - Diagnostics (Green)<ul> <li>Turns on to indicate a fault (see diagnostic pin section)</li> </ul> </li> <li><code>STBY</code> - Standby (Blue)<ul> <li>Turns on when the motor driver is enabled</li> <li>Turns off, when the IC has been reset and the motor driver is in standby mode</li> </ul> </li> <li><code>STAT</code> - User (RGB)<ul> <li>Controlled through <code>GPIO 02</code></li> </ul> </li> </ul> <p></p> <p>The status indicator LEDs on the TMC6300 motor driver.</p>"},{"location":"hardware_overview/#ws2812-rgb-led","title":"WS2812 RGB LED","text":"<p>The WS2812 RGB LED is controlled with a 24-bit (GRB) data signal. This indicator is connected to <code>GPIO 02</code> and the digital output pin from the LED is available through a test point. For more information, please refer to the WS2812C datasheet.</p> <p></p> <p>The status indicator LED (<code>STAT</code>)on the IoT Motor Driver.</p> <p>Info</p> <p>The latest ESP32 Arduino core, now provides a basic RGB LED driver for a WS2812 (or NeoPixel) LED populated the board. For an example of how to utilize the RGB LED driver check out the BlinkRGB example code, which can be accessed from the File drop down menu (i.e File &gt; Examples &gt; ESP32 &gt; GPIO &gt; BlinkRGB).</p>"},{"location":"hardware_overview/#buttons","title":"Buttons","text":"<p>There are four buttons on IoT Motor Driver: RST, BOOT, 13, and 14 buttons.</p> <p></p> <p>Buttons on the IoT Motor Driver.</p> Factory Programming <p>The IoT Motor Driver board will come pre-programmed out of the bag. By default, the 13/14 buttons can be used to operate the motor:</p> <ul> <li>13 - Start/Stop the motor's rotation</li> <li>14 - Switch the direction that the motor is spinning</li> </ul>"},{"location":"hardware_overview/#reset-button","title":"Reset Button","text":"<p>The RST (reset) button allows users to reset the program running on the ESP32-WROOM module without unplugging the board.</p> <p></p> <p>RST button on the IoT Motor Driver.</p>"},{"location":"hardware_overview/#boot-control","title":"Boot Control","text":"<p>The BOOT button can be used to force the board into the serial bootloader. Holding down the BOOT button, while connecting the board to a computer through its USB-C connector or resetting the board will cause it to enter the Firmware Download mode. The board will remain in this mode until it power cycles (happens automatically after uploading new firmware) or the RST button is pressed.</p> <ol> <li>Hold the BOOT button down.</li> <li>Reset the MCU.<ul> <li>While unpowered, connect the board to a computer with through the USB-C connection.</li> <li>While powered, press the RST button.</li> </ul> </li> <li>Release the BOOT button.</li> <li>After programming is completed, reboot the MCU.<ul> <li>Press the RST button.</li> <li>Power cycle the board.</li> </ul> </li> </ol> <p></p> <p>BOOT button on the IoT Motor Driver.</p> <p>Info</p> <p>\u26a1 The BOOT button is also connected to <code>GPIO 0</code>.</p>"},{"location":"hardware_overview/#user-buttons","title":"User Buttons","text":"<p>The 13 and 14 buttons are available for users to configure for their own purposes.</p> <p></p> <p>The user buttons (13 and 14) on the IoT Motor Driver.</p> <p>Factory Programming</p> <p>The IoT Motor Driver board will come pre-programmed out of the bag. By default, these buttons can be used to operate the motor:</p> <ul> <li>13 - Start/Stop the motor's rotation</li> <li>14 - Switch the direction that the motor is spinning</li> </ul> <p>Tip</p> <p>When utilizing the buttons, users should enable the internal pull-up resistors for the GPIO pins.</p>"},{"location":"hardware_overview/#jumpers","title":"Jumpers","text":"Never modified a jumper before? <p>Check out our Jumper Pads and PCB Traces tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <p>There are nine jumpers on the back of the board that can be used to easily modify a hardware connections on the board.</p> <ul> <li>SHLD - This jumper can be used to disconnect the shield of the USB-C connector from <code>GND</code>.</li> <li>MEAS - This jumper can be used to measure the current consumption of the board.</li> <li>BYP - This jumper can be used to bypass the thermal fuse.</li> <li>LED Jumpers<ul> <li>PWR - This jumper can be used to remove power from the red, power LED on the AP2112 LDO regulator.</li> <li>MPWR - This jumper can be used to remove power from the red, power LED on the AP63357 LDO regulator.</li> <li>STBY - This jumper can be used to remove power from the blue, standby LED.</li> <li>DIAG - This jumper can be used to remove power from the green, diagnostic LED.</li> </ul> </li> <li>INT - This jumper can be used to remove the pull-up resistor from the <code>INT</code> pin of the hall-effect sensor.</li> <li>I2C - This jumper can be used to remove the pull-up resistors on the I<sup>2</sup>C bus.</li> </ul> <p></p> <p>The jumpers on the back of the IoT Motor Driver.</p>"},{"location":"hardware_overview/#primary-i2c-bus","title":"Primary I<sup>2</sup>C Bus","text":"<p>The Qwiic connector and hall-effect sensor are attached to the primary I<sup>2</sup>C bus. The primary I<sup>2</sup>C bus for this board utilizes the pin connections, detailed in the table below:</p> <p></p> <p>I<sup>2</sup>C bus connections on the IoT Motor Driver.</p> <p>                  Connection              <code>VDD</code> <code>GND</code> <code>SCL</code> <code>SDA</code>                  Hall-Effect Sensor (TMAG5273) <code>3V3</code> GND <code>GPIO 22</code> <code>GPIO 21</code>                  Qwiic Connector              <code>3V3</code> GND <code>GPIO 22</code> <code>GPIO 21</code> </p>"},{"location":"hardware_overview/#qwiic-connector","title":"Qwiic Connector","text":"<p>A Qwiic connector is provided for users to seamlessly integrate with SparkFun's Qwiic Ecosystem. Otherwise, users can connect their I<sup>2</sup>C devices through the PTH pins broken out on the board.</p> <p></p> <p>Qwiic connector and I<sup>2</sup>C pins on the IoT Motor Driver.</p> What is Qwiic? <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain I<sup>2</sup>C boards together. Play the video below to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic products.</p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the SDA and SCL wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly  every time, right from the start.</p> <p>The PCB connector is part number SM04B-SRSS (Datasheet) or equivalent. The mating connector used on cables is part number SHR04V-S-B or an equivalent (1mm pitch, 4-pin JST connector).</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p>"},{"location":"introduction/","title":"Introduction","text":"<ul> <li> <p> IoT Brushless Motor Driver SKU: ROB-22132 <p> </p> <p> </p> <li> <p>The SparkFun IoT Brushless Motor Driver is an all-in-one development platform. It includes all the components to create a simple IoT device or learn about control systems. On the boaard, users will find an ESP32 microcontroller, a TMC6300 motor driver, a gimbal motor, a TMAG5273 hall-effect sensor, three INA240A1 inline current sensors, an MCP6021T low-side current sensor, two user buttons, a Qwiic connector, a 3-pin JST connector (for the gimbal motor), and a WS2812 RGB LED.</p> <p>The TMC6300 from ADI + Trinamic is a powerful and easy-to-use three-phase motor driver with up to 2A (1.4A<sub>RMS</sub>) of total drive current. Separate high-side and low-side control of the three half-bridges allows for incredible control of each phase of the motor commutation. We've found the Arduino Simple Field Oriented Control library to work well with the TMC6300 motor driver.</p> <p>However, a field-oriented control (FOC) algorithm requires some feedback to close and optimize the control loop. Therefore, we integrated a TMAG5273 hall-effect sensor and INA240A1 current sensor amplifiers (both manufactured by Texas Instruments) into the design of the IoT motor driver board. This allows users to incorporate a position sensor and current sensing into the FOC algorithm or any feedback control loop they choose to implement.</p> <p> \u00a0\u00a0\u00a0Purchase from SparkFun  </p> </li>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>To get started, users will need a few items. Now some users may already have a few of these items, feel free to modify your cart accordingly.</p> <ul> <li>Computer with an operating system (OS) that is compatible with all the software installation requirements.</li> <li> <p>USB 3.1 Cable A to C - 3 Foot - Used to interface with the IoT Brushless Motor Driver (1)</p> <ol> <li>If your computer doesn't have a USB-A slot, then choose an appropriate cable or adapter.</li> </ol> </li> <li> <p>SparkFun IoT Brushless Motor Driver (ESP32 WROOM, TMC6300) (1)</p> <ol> <li>The included gimbal motor requires a 6 to 8V power supply. However, for zero-load, low-speed testing, we have found the power from the USB connection to be sufficient.</li> </ol> </li> </ul> <ul> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot CAB-14743</p> <li> <p> <p>IoT Brushless Motor Driver (ESP32 WROOM, TMC6300) ROB-22132</p> Jumper Modification <p>To modify the jumper, users will need soldering equipment and/or a hobby knife.</p> <p>New to jumper pads?</p> <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <ul> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>Weller WLC100 Soldering Station TOL-14228</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p> <li> <p> <p>Hobby Knife TOL-09200</p>"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>As a more sophisticated product, we will skip over the more fundamental tutorials (i.e. Ohm's Law and What is Electricity?). However, below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p> <p>How to Install CH340 Drivers</p> <li> <p> <p>ESP32 Thing Plus (USB-C)</p> <li> <p> <p>TMC6300 BLDC Motor Driver</p> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p> <li> <p> <p>Logic Levels</p> <li> <p> <p>Pulse Width Modulation</p> <li> <p> <p>Analog vs. Digital</p> <li> <p> <p>I2C</p> <li> <p> <p>SPI</p> <li> <p> <p>Serial Communication</p> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <li> <p> <p>Motors and Selecting the Right One</p> <li> <p> <p>Alternating Current (AC) vs. Direct Current (DC)</p> Need to control a different type of motor? <p>This tutorial is primarily focused on utilizing the TMC6300 motor driver to control a 3-phase brushless DC (BLDC) motor. We would recommend users explore other products for these specific motors and actuators. Below, are additional product tutorials and resources for our other actuator and motor types:</p> Brushed DC MotorsStepper MotorsServos <ul> <li> <p> <p>Hookup Guide for the Qwiic Motor Driver</p> <li> <p> <p>TB6612FNG Hookup Guide</p> <ul> <li> <p> <p>SparkFun ProDriver Hookup Guide</p> <li> <p> <p>Easy Driver Hook-up Guide</p> <ul> <li> <p> <p>Basic Servo Control for Beginners</p> <li> <p> <p>Hobby Servo Tutorial</p> <li> <p> <p>Pi Servo pHAT (v2) Hookup Guide</p>"},{"location":"print_view/","title":"Introduction","text":"<ul> <li> <p> IoT Brushless Motor Driver SKU: ROB-22132 <p> </p> <p> </p> <li> <p>The SparkFun IoT Brushless Motor Driver is an all-in-one development platform. It includes all the components to create a simple IoT device or learn about control systems. On the boaard, users will find an ESP32 microcontroller, a TMC6300 motor driver, a gimbal motor, a TMAG5273 hall-effect sensor, three INA240A1 inline current sensors, an MCP6021T low-side current sensor, two user buttons, a Qwiic connector, a 3-pin JST connector (for the gimbal motor), and a WS2812 RGB LED.</p> <p>The TMC6300 from ADI + Trinamic is a powerful and easy-to-use three-phase motor driver with up to 2A (1.4A<sub>RMS</sub>) of total drive current. Separate high-side and low-side control of the three half-bridges allows for incredible control of each phase of the motor commutation. We've found the Arduino Simple Field Oriented Control library to work well with the TMC6300 motor driver.</p> <p>However, a field-oriented control (FOC) algorithm requires some feedback to close and optimize the control loop. Therefore, we integrated a TMAG5273 hall-effect sensor and INA240A1 current sensor amplifiers (both manufactured by Texas Instruments) into the design of the IoT motor driver board. This allows users to incorporate a position sensor and current sensing into the FOC algorithm or any feedback control loop they choose to implement.</p> <p> \u00a0\u00a0\u00a0Purchase from SparkFun  </p> </li>"},{"location":"print_view/#required-materials","title":"Required Materials","text":"<p>To get started, users will need a few items. Now some users may already have a few of these items, feel free to modify your cart accordingly.</p> <ul> <li>Computer with an operating system (OS) that is compatible with all the software installation requirements.</li> <li> <p>USB 3.1 Cable A to C - 3 Foot - Used to interface with the IoT Brushless Motor Driver (1)</p> <ol> <li>If your computer doesn't have a USB-A slot, then choose an appropriate cable or adapter.</li> </ol> </li> <li> <p>SparkFun IoT Brushless Motor Driver (ESP32 WROOM, TMC6300) (1)</p> <ol> <li>The included gimbal motor requires a 6 to 8V power supply. However, for zero-load, low-speed testing, we have found the power from the USB connection to be sufficient.</li> </ol> </li> </ul> <ul> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot CAB-14743</p> <li> <p> <p>IoT Brushless Motor Driver (ESP32 WROOM, TMC6300) ROB-22132</p> Jumper Modification <p>To modify the jumper, users will need soldering equipment and/or a hobby knife.</p> <p>New to jumper pads?</p> <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <ul> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>Weller WLC100 Soldering Station TOL-14228</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p> <li> <p> <p>Hobby Knife TOL-09200</p>"},{"location":"print_view/#suggested-reading","title":"Suggested Reading","text":"<p>As a more sophisticated product, we will skip over the more fundamental tutorials (i.e. Ohm's Law and What is Electricity?). However, below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p> <p>How to Install CH340 Drivers</p> <li> <p> <p>ESP32 Thing Plus (USB-C)</p> <li> <p> <p>TMC6300 BLDC Motor Driver</p> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p> <li> <p> <p>Logic Levels</p> <li> <p> <p>Pulse Width Modulation</p> <li> <p> <p>Analog vs. Digital</p> <li> <p> <p>I2C</p> <li> <p> <p>SPI</p> <li> <p> <p>Serial Communication</p> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <li> <p> <p>Motors and Selecting the Right One</p> <li> <p> <p>Alternating Current (AC) vs. Direct Current (DC)</p> Need to control a different type of motor? <p>This tutorial is primarily focused on utilizing the TMC6300 motor driver to control a 3-phase brushless DC (BLDC) motor. We would recommend users explore other products for these specific motors and actuators. Below, are additional product tutorials and resources for our other actuator and motor types:</p> Brushed DC MotorsStepper MotorsServos <ul> <li> <p> <p>Hookup Guide for the Qwiic Motor Driver</p> <li> <p> <p>TB6612FNG Hookup Guide</p> <ul> <li> <p> <p>SparkFun ProDriver Hookup Guide</p> <li> <p> <p>Easy Driver Hook-up Guide</p> <ul> <li> <p> <p>Basic Servo Control for Beginners</p> <li> <p> <p>Hobby Servo Tutorial</p> <li> <p> <p>Pi Servo pHAT (v2) Hookup Guide</p>"},{"location":"print_view/#hardware-overview","title":"Hardware Overview","text":""},{"location":"print_view/#board-dimensions","title":"Board Dimensions","text":"<p>The board dimensions are illustrated in the drawing below; the listed measurements are in inches.</p> <p></p> <p>Board dimensions (PDF) for the IoT Motor Driver board, in inches.</p> Need more measurements? <p>For more information about the board's dimensions, users can download the eagle files for the board. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> </p>"},{"location":"print_view/#usb-c-connector","title":"USB-C Connector","text":"<p>The USB connector is provided to power and program the board. For most users, it will be the primary programming interface for the ESP32 module on the IoT Motor Driver board.</p> <p></p> <p>USB-C connector on the IoT Motor Driver board.</p>"},{"location":"print_view/#power","title":"Power","text":"<p>The IoT Motor Driver only requires 5V to power all of the board's components. The simplest method to power the board is through the USB-C connector. Alternatively, the <code>3V3</code> pin can be used to supply power to any of the components, except the motor driver.</p> <p></p> <p>IoT Motor Driver power connections.</p> <p>Below, is a general summary of the power circuitry on the board:</p> <ul> <li><code>3V3</code> - Provides a regulated 3.3V from the USB (5V) power to the board, excluding the TMC6300 motor driver.<ul> <li>Used to power the ESP32-WROOM module, hall-effect and current sensors, CH340C Serial-to-UART bridge, Qwiic connector, and the WS2812 RGB LED.</li> <li>The 3.3V AP2112 LDO regulator can source up to 600mA.</li> <li>Broken out as PTH pin.</li> </ul> </li> <li><code>3V3_A</code> - Provides a regulated 3.3V from the USB (5V) power to only the TMC6300 motor driver.<ul> <li>The motor driver will not function without power from the USB connector.</li> <li>The 3.3V AP63357 LDO regulator can source up to 3.5A.</li> </ul> </li> <li><code>VUSB</code> - The voltage from the USB-C connector, usually 5V.<ul> <li>Power source for the entire board.<ul> <li>Powers the two 3.3V voltage regulators (AP2112 and AP63357).</li> </ul> </li> <li>Features reverse current protection and a thermal fuse.</li> <li><code>MEAS</code> - These pins can be used to measure the current being drawn through the USB connector (see the Jumpers section).</li> </ul> </li> <li><code>GND</code> - The common ground or the 0V reference for the voltage supplies.</li> <li>Qwiic Connector - Provides a regulated 3.3V voltage to the Qwiic devices.</li> </ul> <p>Info</p> <p>For more details, users can reference the schematic and the datasheets of the individual components on the board.</p> Motor Voltage <p>The Gimbal Stabilizer Motor has an operating voltage range of 6 - 8V. However, we have found that it still functions properly with only 3.3V provided by the IoT Motor Driver board.</p>"},{"location":"print_view/#ch340-serial-to-uart","title":"CH340 Serial-to-UART","text":"<p>The CH340 allows the ESP32-WROOM to communicate with a computer/host device through the board's USB-C connection. This allows the board to show up as a device on the serial (or COM) port of the computer. Users will need to install the latest drivers for the computer to recognize the board (see Software Overview section).</p>"},{"location":"print_view/#microcontroller-esp32-wroom","title":"Microcontroller - ESP32-WROOM","text":"<p>The brains of the IoT Motor Driver, is an ESP32-WROOM module with 16MB of flash memory. Espressif's ESP32-WROOM module is a versatile, WiFi+BT+BLE MCU module that targets a wide variety of applications. At the core of this module is the ESP32-D0WDQ6 system on a chip (SoC) which is designed to be both scalable and adaptive microcontroller. Its laundry list of features include:</p> <ul> <li> <p>Features:</p> <ul> <li>Xtensa\u00ae Dual-Core 32-bit LX6 Microprocessor (up to 240MHz)<ul> <li>448KB ROM and 520KB SRAM</li> <li>16MB of Embedded SPI Flash Storage</li> </ul> </li> <li>Cryptographic Hardware Accelerators<ul> <li>AES, SHA2, ECC, RSA-4096</li> </ul> </li> <li>Integrated 802.11 b/g/n WiFi 2.4GHz Transceiver (up to 150Mbps)</li> <li>Integrated dual-mode Bluetooth (Bluetooth v4.2 and BLE)</li> <li>26 GPIO (including strapping pins)<ul> <li>8x Capacitive Touch Electrodes</li> </ul> </li> <li>Operating Voltage: 3.0 to 3.6V<ul> <li>WiFi: 380mA (peak)</li> <li>Light-Sleep: 800\u00b5A</li> <li>Deep-Sleep: 10 - 150\u00b5A</li> </ul> </li> </ul> </li> <li> <p> ESP32-WROOM module on the IoT Motor Driver. </p> </li> </ul> <p>Warning</p> <p>Users should be aware of the following nuances and details of this board</p> <ul> <li>The ESP32-WROOM is only compatible with 2.4GHz WiFi networks; it will not work on the 5GHz bands.</li> <li>For details on the boot mode configuration, please refer to section 3.3 Strapping Pins of the ESP32-WROOM module datasheet.</li> </ul> <p>Info</p> <p>The ESP32-WROOM module has various power modes:</p> <ul> <li>Active - The chip radio is powered on. The chip can receive, transmit, or listen.</li> <li>Modem Sleep - The CPU is operational and the clock is configurable. The Wi-Fi/Bluetooth baseband and radio are disabled.</li> <li>Light Sleep - The CPU is paused. The RTC memory and RTC peripherals, as well as the ULP coprocessor are running.</li> <li>Deep Sleep - Only the RTC memory and RTC peripherals are powered on. The ULP coprocessor is functional.</li> <li>Hibernation - Only one RTC timer on the slow clock and certain RTC GPIOs are active.</li> <li>Off - Chip is powered off</li> </ul> <p>For more information on the power management of the ESP32-WROOM module, pleaser refer to Section 3.7 and Tables: 8 and 17 of the ESP32 SoC Datasheet.</p>"},{"location":"print_view/#debugging","title":"Debugging","text":"<p>For users interested in debugging their code, the JTAG pins are broken out on the board. However, the debugging feature is only available through the ESP-IDF.</p> <ul> <li><code>TMS</code>: <code>GPIO 14</code></li> <li><code>TDI</code>: <code>GPIO 12</code></li> <li><code>TCK</code>: <code>GPIO 13</code></li> <li><code>TDO</code>: <code>GPIO 15</code></li> </ul> <p></p> <p>The JTAG pins of the ESP32-WROOM module on the IoT Motor Driver.</p>"},{"location":"print_view/#firmware-download-mode","title":"Firmware Download Mode","text":"<p>Users can manually force the board into the serial bootloader with the BOOT button. Please, refer to the Boot Button section below for more information.</p>"},{"location":"print_view/#peripherals-and-io","title":"Peripherals and I/O","text":"<p>Warning</p> <p>Users should be aware of the following nuances of this board</p> <ul> <li>\u26a1 All the GPIO on the IoT Motor Driver are 3.3V pins.<ul> <li>The I/O pins are not 5V-tolerant! To interface with higher voltage components, a logic level adapter is recommended.</li> </ul> </li> <li>\u26a1 There are electrical limitations to the amount of current that the ESP32-WROOM module can sink or source. For more details, check out the ESP32-WROOM module datasheet.</li> <li>There are some limitations to the ADC performance, see the Note from the ADC Characteristics section of the ESP32 SoC datasheet.</li> </ul> <p>The ESP32-WROOM module has 26 multifunctional GPIO, of which, 16 I/O pins are used to interface with motor driver, sensors, and status LED on the board. Additionally, 13 I/O pins are broken out to PTH pins and the users buttons. All of the IoT Motor Driver pins have a .1\" pitch spacing for headers.</p> <p>While all of the GPIO pins are capable of functioning as digital I/O pins, various pins can have additional capabilities with the pin multiplexing feature of the ESP32 SoC. For more technical specifications on the I/O pins, please refer to the ESP32 SoC datasheet.</p> <ul> <li>13x 12-bit analog to digital converter (ADC) channels</li> <li>3x UARTs (only two are configured by default in the Arduino IDE, one UART is used for bootloading/debug)</li> <li>3x SPI (only one is configured by default in the Arduino IDE)</li> <li>2x I<sup>2</sup>C (only one is configured by default in the Arduino IDE)</li> <li>2x I<sup>2</sup>S Audio</li> <li>2x digital-to-analog converter (DAC) channels</li> <li>16x 20-bit PWM outputs</li> <li>8x Capacitive Touch Inputs</li> </ul> <p>Info</p> <p>Users should be aware of the following limitations for the board in the Arduino IDE.</p> <ul> <li>Not all of the features, listed above, are available in the Arduino IDE. For the full capabilities of the ESP32, the Espressif IDF should be utilized.<ul> <li>Only one I<sup>2</sup>C bus is defined.</li> <li>Only two UART interfaces are available.<ul> <li>UART (USB): <code>Serial</code></li> <li><code>RX</code>/<code>TX</code> Pins: <code>Serial1</code></li> </ul> </li> <li>Only one SPI bus is defined.</li> </ul> </li> </ul>"},{"location":"print_view/#peripheral-devices","title":"Peripheral Devices","text":"<p>This development board features several components operating together to create an IoT device. Their connections are shown in the diagram below and their operations are listed in the boxes below. For more details on each component, please refer to the sections below.</p> <p></p> <p>Block diagram of the IoT Motor Driver board's peripherals.</p> <ul> <li> <p>Inputs</p> <ul> <li>TMC6300 Motor Driver<ul> <li>Diagnostic Pin</li> </ul> </li> <li>TMAG5273 Hall-Effect Sensor</li> <li>INA240 Current-Sense Amplifier</li> <li>MCP6021 Operational Amplifier</li> <li>User Buttons</li> </ul> </li> <li> <p>Outputs</p> <ul> <li>TMC6300 Motor Driver<ul> <li>Half-Bridge Pins</li> <li>Standby Pin</li> </ul> </li> <li>RGB Status LED</li> </ul> </li> </ul>"},{"location":"print_view/#pin-functionality","title":"Pin Functionality","text":"<p>There are several pins that have special functionality in addition to general digital I/O. These pins and their additional functions are listed in the tabs below. For more technical specifications on the I/O pins, you can refer to the schematic, ESP32-WROOM module datasheet, ESP32 SoC datasheet, and documentation for the ESP32 Arduino core.</p> Digital I/O PinsAnalog InputsPWM &amp; Analog (DAC) OutputsSerial PinsSPI PinsI<sup>2</sup>C Pins <p>Any GPIO pin on the ESP32-WROOM module can function as a digital I/O (input or output). However, users will need to declare the <code>pinMode()</code> (link) in the setup of their sketch (programs written in the Arduino IDE) to configure a pin as an input or an output.</p> <ul> <li> <p>Inputs</p> <p>When configured properly, an input pin will be looking for a HIGH or LOW state. Input pins are High Impedance and takes very little current to move the input pin from one state to another.</p> <p> <code>DIAG</code> (TMC6300) <code>GPIO 34</code> <code>INT</code> (TMAG5273) <code>GPIO 04</code> Button 13 <code>GPIO 13</code> Button 14 <code>GPIO 14</code> <p></p> <li> <p>Outputs</p> <p>When configured as an output the pin will be at a HIGH or LOW voltage. Output pins are Low Impedance: This means that they can provide a relatively substantial amount of current to other circuits.</p> <p> <code>VIO</code> (TMC6300) <code>GPIO 05</code> WS2812 <code>GPIO 02</code> <p></p> <p>Warning</p> <p>\u26a1 There are electrical limitations to the amount of current that the ESP32-WROOM module can sink or source. For more details, check out the ESP32-WROOM module datasheet.</p> <p>Tip</p> <p>Pins cannot be configured to operate simultaneously as an input and output, without implementing the pin as an interrupt.</p> <p>The ESP32-WROOM module provides a 12-bit ADC input on thirteen of its I/O pins. This functionality is accessed in the Arduino IDE using the <code>analogRead(pin)</code> function. (The available ADC pins are highlighted in the image below.)</p> <p> Current Sensor INA240 (<code>U</code>) INA240 (<code>V</code>) INA240 (<code>W</code>) MCP6021 Analog Input <code>GPIO 35</code> <code>GPIO 36</code> <code>GPIO 39</code> <code>GPIO 32</code> <p></p> <p>Info</p> <p>By default, in the Arduino IDE, <code>analogRead()</code> returns a 10-bit value. To change the resolution of the value returned by the <code>analogRead()</code> function, use the <code>analogReadResolution(bits)</code> function.</p> <p>Tip</p> <p>To learn more about analog vs. digital signals, check out this great tutorial.</p> <ul> <li> <p> <p>Analog vs. Digital</p> <p>The ESP32-WROOM module supports up to sixteen channels of 20-bit PWM (Pulse Width Modulation) outputs on any of its I/O pins. This is accessed in the Arduino IDE using the <code>analogWrite(pin, value)</code> function. (Any I/O pin can be used for the PWM outputs; the available DAC pins, with true analog outputs, are highlighted in the image below.)</p> <p></p> <p> Motor Driver <code>UH</code> <code>UL</code> <code>VH</code> <code>VL</code> <code>WH</code> <code>WL</code> PWM Output <code>GPIO 16</code> <code>GPIO 17</code> <code>GPIO 18</code> <code>GPIO 23</code> <code>GPIO 19</code> <code>GPIO 33</code> <p></p> <p>Info</p> <p>By default, in the Arduino IDE, <code>analogWrite()</code> accepts an 8-bit value. To change the resolution of the PWM signal for the <code>analogWrite()</code> function, use the <code>analogWriteResolution(bits)</code> function. (The PWM output is not a true analog signal.)</p> <p>Tip</p> <p>To learn more about pulse width modulation (PWM), check out this great tutorial.</p> <ul> <li> <p> <p>Pulse Width Modulation</p> <p>The ESP32-WROOM module provides three UART ports. By default, the UART port for the USB connection (<code>Serial</code>) and the labeled UART I/O pins on the board (<code>Serial1</code>) can be accessed through the Arduino IDE using the serial communication class.</p> <p>Info</p> <p>By default, in the Arduino IDE, the  board definition supports:      <ul> <li><code>Serial</code> - UART (USB)</li> <li><code>Serial1</code> - Pins: <code>RX</code>/<code>TX</code> (<code>GPIO 16</code>/<code>GPIO 17</code>)</li> </ul> Note <ul> <li>The <code>GPIO 16</code> and <code>GPIO 17</code> pins of <code>Serial1</code> are already dedicated to the <code>UH</code>/<code>UL</code> half-bridge on the TMC63000 motor driver and are not broken out for users to access.</li> <li>In order to utilize the serial communication on the strapping pins, users will need to create a custom serial port object and declare which pins to access.</li> </ul> <p>Tip</p> <p>To learn more about serial communication, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Communication</p> <p>Tip</p> <p>We have noticed that with the ESP32 Arduino core, <code>Serial.available()</code> does not operate instantaneously. This is due to an interrupt triggered by the UART, to empty the FIFO when the <code>RX</code> pin is inactive for two byte periods:</p> <ul> <li>At 9600 baud, <code>hwAvailable</code> takes [<code>number of bytes received</code> + 2] x 1 ms = 11 ms before the UART indicates that data was received from: <code>\\r\\nERROR\\r\\n</code>.</li> <li>At 115200 baud, <code>hwAvailable</code> takes [<code>number of bytes received</code> + 2] x .087 ms = ~1 ms before the UART indicates that data was received from: <code>\\r\\nERROR\\r\\n</code>.</li> </ul> <p>For more information, please refer to this chatroom discussion.</p> <p>The ESP32-WROOM module provides three SPI buses. By default, in the Arduino IDE, the SPI class is configured to utilize pins <code>GPIO 18</code> (SCK), <code>GPIO 19</code> (POCI), <code>GPIO 23</code> (PICO). In order to utilize the other SPI ports or objects, users will need to create a custom SPI object and declare which pins to access.</p> <p>Info</p> <p>To comply with the latest OSHW design practices, we have adopted the new SPI signal nomenclature (SDO/SDI and PICO/POCI). The terms Master and Slave are now referred to as Controller and Peripheral. The <code>MOSI</code> signal on a controller has been replaced with <code>SDO</code> or <code>PICO</code>. Please refer to this announcement on the decision to deprecate the MOSI/MISO terminology and transition to the SDO/SDI naming convention.</p> <p> SCK <code>GPIO 18</code> (<code>SCK</code>) SDI or POCI <code>GPIO 19</code> (<code>MISO</code>) SDO or PICO <code>GPIO 23</code> (<code>MOSI</code>) CS <code>GPIO 5</code> (<code>SS</code>) <p></p> Note <ul> <li>The <code>GPIO 18</code>,<code>GPIO 19</code>, and <code>GPIO 23</code> pins of the <code>SPI</code> bus are already dedicated to the <code>VH</code>/<code>WH</code>/<code>VL</code> MOSFETs on the TMC63000 motor driver and are not broken out for users to access.</li> <li>The <code>CS</code> pin associated with <code>GPIO 05</code> is also already dedicated to the <code>STBY</code> pin of the TMC63000 motor driver and is not broken out for users to access.</li> </ul> <p>Tip</p> <p>To learn more about the serial peripheral interface (SPI) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Peripheral Interface (SPI)</p> <p>The ESP32-WROOM module module can support up to two I<sup>2</sup>C buses. By default, in the Arduino IDE, the Wire class is configured to utilize pins <code>GPIO 21</code> (SDA) and <code>GPIO 22</code> (SCL). These pins share the same I<sup>2</sup>C bus with the Qwiic connector and TMAG5273 hall-effect sensor. In order to utilize the other I<sup>2</sup>C ports, users will need to create a custom Wire object and declare which pins to access.</p> <ul> <li> <p> <p>I<sup>2</sup>C Pins</p> SCL <code>GPIO 22</code> SDA <code>GPIO 21</code> <p></p> <p>TMAG5273 I<sup>2</sup>C Address:</p> <ul> <li>0x35 (Default) (7-bit)</li> <li>0x6A (write)/0x6B (read)</li> </ul> <li> <p> Default I<sup>2</sup>C bus connections for the IoT Motor Driver. </p> </li> <p>Tip</p> <p>To learn more about the inter-integrated circuit (I<sup>2</sup>C) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>Inter-Integrated Circuit (I<sup>2</sup>C)</p>"},{"location":"print_view/#motor-driver-tmc6300","title":"Motor Driver - TMC6300","text":"<p>The TMC6300 from Trinamic Motion Control, part of Analog Devices, is a low voltage, 3-Phase BLDC/PMSM motor driver utilizing separate high-side and low-side control signals for its three half-bridges.</p> <ul> <li> <p>Features:</p> <ul> <li>VIN: 2.0V to 11.0V<ul> <li>Operating current: 7mA</li> <li>Standby current: 30nA</li> </ul> </li> <li>VOUT: 1.8V</li> <li>3 Half-Bridges<ul> <li>3 High-side MOSFETs</li> <li>3 Low-side MOSFETs</li> </ul> </li> <li>I/O Supply Voltage Input</li> <li>Diagnostic Output</li> <li>Overtemperature Protection<ul> <li>Shutdown Temperature: 150\u00b0C</li> <li>Typical Power Dissipation: 1W</li> </ul> </li> <li>Short Protection</li> </ul> <p>Info</p> <p>For more details, please refer to the TMC6300 datasheet.</p> </li> <li> <p> TMC6300 chip on the IoT Motor Driver. </p> <p>For users unfamiliar with the TMC6300 motor driver, please check out our hookup guide below.</p> <ul> <li> <p> <p>TMC6300 BLDC Motor Driver Hookup Guide</p>"},{"location":"print_view/#half-bridges","title":"Half-Bridges","text":"<p>The TMC6300 features high-side and low-side MOSFET pairs of the three available half-bridges which control the commutation of the three motor phases.</p> <p></p> <p>6 PWM control of a 3-phase motor commutation. (Source: Modified from the Block commutation vs. FOC in power tool motor control application note)</p> InputOutput <p>The electronic commutation sequence for these MOSFETs will depend on the motor that is connected. For most cases, users will provide a PWM signal to each of these pins. These are active-high pins.</p> <p> ESP32-WROOM <code>16</code> <code>17</code> <code>18</code> <code>23</code> <code>19</code> <code>33</code> Motor Driver <code>UH</code> <code>UL</code> <code>VH</code> <code>VL</code> <code>WH</code> <code>WL</code> <p></p> Active High <p>By pulling the pin high, the MOSFET will enable power to flow through that section of the half-bridge.</p> <p>With the electronic commutation sequence provided to the half-bridges, the output motor phases will drive a connected motor.</p> <p>  The three motor phase outputs (<code>U</code>/<code>V</code>/<code>W</code>) from the TMC6300 are used to drive the gimbal motor, attached through the JST connector.  </p>"},{"location":"print_view/#motor-commutation","title":"Motor Commutation","text":"<p>The TMC6300 relies on an electrical commutation sequence/signal to drive the motor phases to a BLDC or PMSM motor. The commutation signals for these motors are trapezoidal for BLDC motors and sinusoidal for PMSM motors.</p> <ul> <li> <p>      Trapezoidal motor commutation.      </p> </li> <li> <p>      Sinusoidal motor commutation.      </p> </li> </ul> <p> (Source: Brushless-DC Motor Driver Considerations and Selection Guide application note) </p> <p>Gimbal Motor</p> <p>Based on measuring the output from one of the coils, our gimbal motor is a PMSM and would require a sinusoidal waveform to drive the motor. It should be noted that a trapezodial waveform can probably be used; however, users may notice effects such as cogging.</p> <p>  Sinusoidal PWM signal. (Source: Demystifying BLDC motor commutation: Trap, Sine, &amp; FOC)  </p> <p>For a trapezoidal signal, the high-side (HS) and low-side (LS) MOSFETs, can just be driven high or low. However, in order to approximate a sinusoidal signal, a progressively varying PWM signal must be provided with all six signals in sync with each other.</p>"},{"location":"print_view/#viostandby-pin","title":"<code>VIO</code>/Standby Pin","text":"<p>In it's default configuration, the <code>VIO</code> pin is used to enable the motor driver and set the logic level voltage of the TMC6300 inputs. However, the <code>VIO</code> pin also operates as a standby pin when it is pulled <code>LOW</code>. In standby, the TMC6300 resets and sits in standby mode.</p> <p>Users can control the <code>VIO</code> pin with <code>GPIO 05</code> on the ESP32-WROOM module, to reset the TMC6300 or put it in standby mode.</p>"},{"location":"print_view/#diagnostic-pin","title":"Diagnostic Pin","text":"<p>The diagnostic pin is triggered based on different faults (i.e. shorts and overtemperature) detected by the IC. By default, the status will be indicated by the, green diagnostic, <code>DIAG</code> LED and will remail <code>LOW</code> until triggered. Once triggered, users will need to disable and reset the TMC6300 or power cycle the board.</p> <p>Users can monitor the diagnostic pin with <code>GPIO 34</code> on the ESP32-WROOM module, to determine if the TMC6300 need to be reset to clear a fault.</p>"},{"location":"print_view/#current-sense-pin","title":"Current Sense Pin","text":"<p>The current sense pin is the foot point of the <code>U</code> and <code>V</code> half-bridges, with a 0.12\u03a9 resistor attached. Users can measure the voltage across the resistor to determine the current flowing to the motor (see the Low-side Op Amp - MCP6021 section below).</p>"},{"location":"print_view/#hall-effect-sensor-tmag5273","title":"Hall-Effect Sensor - TMAG5273","text":"<p>The TMAG5273 from Texas Instruments, is a 3-axis hall-effect sensor utilizing a 12-bit ADC. For more information, please refer to the TMAG5273 datasheet.</p> <ul> <li> <p>Features:</p> <ul> <li>I<sup>2</sup>C Address:<ul> <li>0x35 (Default) (7-bit)</li> <li>0x6A (write)/0x6B (read)</li> </ul> </li> <li>Magnetic Range (Sensitivity):<ul> <li>\u00b1 40mT (820 LSB/mT)</li> <li>\u00b1 80mT (410 LSB/mT)</li> </ul> </li> <li>Magnetic Drift: 5%</li> <li>Rotational Accuracy: \u00b1 0.5\u00b0/360\u00b0 rotation</li> <li>Voltage Range: 1.7 - 3.6V<ul> <li>Sleep: 5nA</li> <li>Wake-Up/Sleep: 1\u00b5A</li> <li>Active: 2.3mA</li> </ul> </li> <li>Operating Temperature: \u201340 - 125\u00b0C</li> <li>Integrated temperature compensation</li> <li>Configurable sample rate</li> </ul> </li> <li> <p> The TMAG5273 hall-effect sensor on the IoT Motor Driver. </p> <p>Magnetic Axes</p> <p>On the IoT Motor Driver, users will primarily be interested in magnetic field of the X-Y axes to measure the position of the gimbal motor.</p> <p> The magnetic axes of TMAG5273 hall-effect sensor. </p> </li> </ul> <p>Info</p> <p>For more details, please refer to the TMAG5273 datasheet.</p>"},{"location":"print_view/#interrupt-pin","title":"Interrupt Pin","text":"<p>The interrupt pin of the TMAG5723 can be configured in different modes to utilize either the <code>INT</code> or <code>SCL</code> pins.</p> <ul> <li>No interrupt</li> <li>Interrupt through <code>INT</code></li> <li>Interrupt through <code>INT</code> except when I2C busy</li> <li>Interrupt through <code>SCL</code></li> <li>Interrupt through <code>SCL</code> except when I2C busy</li> </ul> <p>Tip</p> <p>We recommend utilizing the default <code>INT</code> pin to trigger interrupts; as it is already connected to <code>GPIO 04</code> of the ESP32-WROOM module.</p> Bus Contention <p>Texas Instruments does not recommend sharing the I<sup>2</sup>C bus with multiple devices when using the <code>SCL</code> pin for the interrupt function. The <code>SCL</code> interrupt can potentially corrupt the transactions with other devices, when present on the same I<sup>2</sup>C bus.</p> <p>Note</p> <p>The TMAG5273 is programmed to detect a magnetic threshold in wake-up or sleep mode. Once the magnetic threshold cross is detected, the device asserts a latched interrupt signal through the INT pin, and goes back to stand-by mode. The interrupt latch is cleared through the <code>SCL</code> pin.</p>"},{"location":"print_view/#current-sensors","title":"Current Sensors","text":"<p>There are two different types of Op Amps on the board to amplify the input voltage for the current measurements.</p> <ul> <li>The INA240 is used for the in-line current measurements between the TMC6300 and the gimabal motor.</li> <li>The MCP6021 is used on the low-side current measurement of the TMC63000's half-bridges.</li> </ul> <p> Current Sensor INA240 (<code>U</code>) INA240 (<code>V</code>) INA240 (<code>W</code>) MCP6021 Analog Input <code>GPIO 35</code> <code>GPIO 36</code> <code>GPIO 39</code> <code>GPIO 32</code> <p></p>"},{"location":"print_view/#inline-ina240","title":"Inline - INA240","text":"<p>The INA240 from Texas Instruments, is a voltage-output, current-sense amplifier. For more information, please refer to the INA240 datasheet.</p> <ul> <li> <p> The INA240 current-sense amplifier on the IoT Motor Driver. </p> </li> <li> <p> Configured Gain 20 &amp;PlusMn;0.2% Bandwidth 100kHz Voltage Range Range: 2.7 - 5.5V Quiescent Current 1.8 - 2.6mA Operating Temperature \u201340 - 125\u00b0C </p> </li> </ul>"},{"location":"print_view/#low-side-op-amp-mcp6021","title":"Low-side Op Amp - MCP6021","text":"<p>The MCP6021 from Microchip Technology, Inc., is a rail-to-rail input and output operational amplifier. The chip . For more information, please refer to the MCP6021 datasheet.</p> <ul> <li> <p> The MCP6021 Op Amp on the IoT Motor Driver. </p> </li> <li> <p> Configured Gain 21 Bandwidth 10MHz Voltage Range Range: 2.5 - 5.5V Quiescent Current 0.5 - 1.35mA Operating Temperature \u201340 - 125\u00b0C </p> </li> </ul>"},{"location":"print_view/#status-leds","title":"Status LEDs","text":"<p>There are five status LEDs on the TMC6300 motor driver:</p> <ul> <li><code>PWR</code> - Power (Red)<ul> <li>Turns on once power is supplied through the USB-C connector</li> </ul> </li> <li><code>MPWR</code> - Power (Red)<ul> <li>Turns on once power is supplied through the USB-C connector</li> </ul> </li> <li><code>DIAG</code> - Diagnostics (Green)<ul> <li>Turns on to indicate a fault (see diagnostic pin section)</li> </ul> </li> <li><code>STBY</code> - Standby (Blue)<ul> <li>Turns on when the motor driver is enabled</li> <li>Turns off, when the IC has been reset and the motor driver is in standby mode</li> </ul> </li> <li><code>STAT</code> - User (RGB)<ul> <li>Controlled through <code>GPIO 02</code></li> </ul> </li> </ul> <p></p> <p>The status indicator LEDs on the TMC6300 motor driver.</p>"},{"location":"print_view/#ws2812-rgb-led","title":"WS2812 RGB LED","text":"<p>The WS2812 RGB LED is controlled with a 24-bit (GRB) data signal. This indicator is connected to <code>GPIO 02</code> and the digital output pin from the LED is available through a test point. For more information, please refer to the WS2812C datasheet.</p> <p></p> <p>The status indicator LED (<code>STAT</code>)on the IoT Motor Driver.</p> <p>Info</p> <p>The latest ESP32 Arduino core, now provides a basic RGB LED driver for a WS2812 (or NeoPixel) LED populated the board. For an example of how to utilize the RGB LED driver check out the BlinkRGB example code, which can be accessed from the File drop down menu (i.e File &gt; Examples &gt; ESP32 &gt; GPIO &gt; BlinkRGB).</p>"},{"location":"print_view/#buttons","title":"Buttons","text":"<p>There are four buttons on IoT Motor Driver: RST, BOOT, 13, and 14 buttons.</p> <p></p> <p>Buttons on the IoT Motor Driver.</p> Factory Programming <p>The IoT Motor Driver board will come pre-programmed out of the bag. By default, the 13/14 buttons can be used to operate the motor:</p> <ul> <li>13 - Start/Stop the motor's rotation</li> <li>14 - Switch the direction that the motor is spinning</li> </ul>"},{"location":"print_view/#reset-button","title":"Reset Button","text":"<p>The RST (reset) button allows users to reset the program running on the ESP32-WROOM module without unplugging the board.</p> <p></p> <p>RST button on the IoT Motor Driver.</p>"},{"location":"print_view/#boot-control","title":"Boot Control","text":"<p>The BOOT button can be used to force the board into the serial bootloader. Holding down the BOOT button, while connecting the board to a computer through its USB-C connector or resetting the board will cause it to enter the Firmware Download mode. The board will remain in this mode until it power cycles (happens automatically after uploading new firmware) or the RST button is pressed.</p> <ol> <li>Hold the BOOT button down.</li> <li>Reset the MCU.<ul> <li>While unpowered, connect the board to a computer with through the USB-C connection.</li> <li>While powered, press the RST button.</li> </ul> </li> <li>Release the BOOT button.</li> <li>After programming is completed, reboot the MCU.<ul> <li>Press the RST button.</li> <li>Power cycle the board.</li> </ul> </li> </ol> <p></p> <p>BOOT button on the IoT Motor Driver.</p> <p>Info</p> <p>\u26a1 The BOOT button is also connected to <code>GPIO 0</code>.</p>"},{"location":"print_view/#user-buttons","title":"User Buttons","text":"<p>The 13 and 14 buttons are available for users to configure for their own purposes.</p> <p></p> <p>The user buttons (13 and 14) on the IoT Motor Driver.</p> <p>Factory Programming</p> <p>The IoT Motor Driver board will come pre-programmed out of the bag. By default, these buttons can be used to operate the motor:</p> <ul> <li>13 - Start/Stop the motor's rotation</li> <li>14 - Switch the direction that the motor is spinning</li> </ul> <p>Tip</p> <p>When utilizing the buttons, users should enable the internal pull-up resistors for the GPIO pins.</p>"},{"location":"print_view/#jumpers","title":"Jumpers","text":"Never modified a jumper before? <p>Check out our Jumper Pads and PCB Traces tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <p>There are nine jumpers on the back of the board that can be used to easily modify a hardware connections on the board.</p> <ul> <li>SHLD - This jumper can be used to disconnect the shield of the USB-C connector from <code>GND</code>.</li> <li>MEAS - This jumper can be used to measure the current consumption of the board.</li> <li>BYP - This jumper can be used to bypass the thermal fuse.</li> <li>LED Jumpers<ul> <li>PWR - This jumper can be used to remove power from the red, power LED on the AP2112 LDO regulator.</li> <li>MPWR - This jumper can be used to remove power from the red, power LED on the AP63357 LDO regulator.</li> <li>STBY - This jumper can be used to remove power from the blue, standby LED.</li> <li>DIAG - This jumper can be used to remove power from the green, diagnostic LED.</li> </ul> </li> <li>INT - This jumper can be used to remove the pull-up resistor from the <code>INT</code> pin of the hall-effect sensor.</li> <li>I2C - This jumper can be used to remove the pull-up resistors on the I<sup>2</sup>C bus.</li> </ul> <p></p> <p>The jumpers on the back of the IoT Motor Driver.</p>"},{"location":"print_view/#primary-i2c-bus","title":"Primary I<sup>2</sup>C Bus","text":"<p>The Qwiic connector and hall-effect sensor are attached to the primary I<sup>2</sup>C bus. The primary I<sup>2</sup>C bus for this board utilizes the pin connections, detailed in the table below:</p> <p></p> <p>I<sup>2</sup>C bus connections on the IoT Motor Driver.</p> <p>                  Connection              <code>VDD</code> <code>GND</code> <code>SCL</code> <code>SDA</code>                  Hall-Effect Sensor (TMAG5273) <code>3V3</code> GND <code>GPIO 22</code> <code>GPIO 21</code>                  Qwiic Connector              <code>3V3</code> GND <code>GPIO 22</code> <code>GPIO 21</code> </p>"},{"location":"print_view/#qwiic-connector","title":"Qwiic Connector","text":"<p>A Qwiic connector is provided for users to seamlessly integrate with SparkFun's Qwiic Ecosystem. Otherwise, users can connect their I<sup>2</sup>C devices through the PTH pins broken out on the board.</p> <p></p> <p>Qwiic connector and I<sup>2</sup>C pins on the IoT Motor Driver.</p> What is Qwiic? <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain I<sup>2</sup>C boards together. Play the video below to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic products.</p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the SDA and SCL wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly  every time, right from the start.</p> <p>The PCB connector is part number SM04B-SRSS (Datasheet) or equivalent. The mating connector used on cables is part number SHR04V-S-B or an equivalent (1mm pitch, 4-pin JST connector).</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p>"},{"location":"print_view/#hardware-assembly","title":"Hardware Assembly","text":""},{"location":"print_view/#usb-programming","title":"USB Programming","text":"<p>The USB connection is utilized for programming and serial communication. Users only need to plug their IoT Motor Driver into a computer using a USB-C cable.</p> <p></p> <p>The IoT Motor Driver with USB-C cable attached.</p>"},{"location":"print_view/#headers","title":"Headers","text":"New to soldering? <p>If you have never soldered before or need a quick refresher, check out our How to Solder: Through-Hole Soldering guide.</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <p>The pins for the IoT Motor Driver are broken out into 0.1\"-spaced pins on the outer edges of the board. When selecting headers, be sure you are aware of the functionality you require.</p> <p></p> <p>Soldering headers to the IoT Motor Driver.</p>"},{"location":"print_view/#qwiic-devices","title":"Qwiic Devices","text":"<p>The Qwiic system allows users to effortlessly prototype with a Qwiic compatible I<sup>2</sup>C device without soldering. Users can attach any Qwiic compatible sensor or board, with just a Qwiic cable. (*The example below, is for demonstration purposes and is not pertinent to the board functionality or this tutorial.)</p> <p></p> <p>The BME688 environmental and VL53L1X distance Qwiic sensor boards connected to the IoT Motor Driver.</p>"},{"location":"print_view/#software-overview","title":"Software Overview","text":""},{"location":"print_view/#ch340-driver","title":"CH340 Driver","text":"<p>Users will need to install the appropriate driver for their computer to recognize the serial-to-UART chip on their board/adapter. Most of the latest operating systems will recognize the CH340C chip on the board and automatically install the required driver.</p> <p>To manually install the CH340 driver on their computer, users can download it from the WCH website. For more information, check out our How to Install CH340 Drivers Tutorial.</p> <p></p> <p>How to Install CH340 Drivers</p>"},{"location":"print_view/#arduino-ide","title":"Arduino IDE","text":"<p>Tip</p> <p>For first-time users, who have never programmed before and are looking to use the Arduino IDE, we recommend beginning with the SparkFun Inventor's Kit (SIK), which is designed to help users get started programming with the Arduino IDE.</p> <p>Most users may already be familiar with the Arduino IDE and its use. However, for those of you who have never heard the name Arduino before, feel free to check out the Arduino website. To get started with using the Arduino IDE, check out our tutorials below:</p> <ul> <li> <p> <p>What is an Arduino?</p> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p>"},{"location":"print_view/#install-board-definition","title":"Install Board Definition","text":"<p>Install the latest ESP32 board definitions in the Arduino IDE.</p> <p> Installing Board Definitions in the Arduino IDE </p> <p>Info</p> <p>For more instructions, users can follow this tutorial on Installing Additional Cores provided by Arduino. Users will also need the <code>.json</code> file for the Espressif Arduino core:</p> <pre><code>https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json\n</code></pre> <p>When selecting a board to program in the Arduino IDE, users should select the SparkFun ESP32 Thing Plus C from the <code>Tools</code> drop-down menu (_i.e. Tools &gt; Board &gt; ESP32 Arduino &gt; SparkFun ESP32 Thing Plus C). Alternatively, users can also select the ESP32 Dev Module; however, they may lose some pin assignments.</p> <p></p> <p>Select the SparkFun ESP32 Thing Plus C from the <code>Tools</code> drop-down menu in the Arduino IDE.</p> Arduino IDE 2.x.x - Alternative Method <p>In the newest version of the Arduino IDE 2.<code>x</code>.<code>x</code>, users can also select their board (green) and port (blue) from the <code>Select Board &amp; Port</code> dropdown menu (yellow).</p> <p> Selecting the SparkFun ESP32 Thing Plus C and COM5 port from the Select Board &amp; Port drop-down menu in the Arduino IDE (v2.0.3). </p>"},{"location":"print_view/#sparkfun-tmag5273-arduino-library","title":"SparkFun TMAG5273 Arduino Library","text":"<p>The SparkFun TMAG5273 Arduino Library can be installed from the library manager in the Arduino IDE.</p> <p></p> <p>SparkFun TMAG5273 Arduino library in the library manager of the Arduino IDE.</p> Arduino IDE (v1.x.x) <p>In the Arduino IDE v1.x.x, the library manager will have the following appearance for the SimpleFOC library:</p> <p> SparkFun TMAG5273 Arduino library in the library managerof the Arduino IDE (v1.x.x). </p> <p>This library will be primarily used to interact with the TMAG5273 hall-effect sensor and return the rotation angle of the motor.</p>"},{"location":"print_view/#simplefoc-arduino-library","title":"SimpleFOC Arduino Library","text":"<p>The Simple Field Oriented Control Library can be installed from the library manager in the Arduino IDE.</p> <p></p> <p>SimpleFOC library in the library manager of the Arduino IDE.</p> Arduino IDE (v1.x.x) <p>In the Arduino IDE v1.x.x, the library manager will have the following appearance for the SimpleFOC library:</p> <p> SimpleFOC library in the library manager of the Arduino IDE (v1.x.x). </p> <p>This library utilizes a motor control scheme called field oriented control (FOC), which can utilize a feedback control loop to drive a motor with a higher power efficiency and precision characteristics, like evenly distributed torque control.</p> <p>Info</p> <p>For more details about the library, check out the online documentation.</p> <p>Supported Hardware</p> <p>For a detailed and up-to-date list of the hardware supported by this library, check out the library's documentation. The following are excerpts taken from the library's documentation page:</p> MicrocontrollersMotor DriversMotors <p>Arduino SimpleFOClibrary supports:</p> MCU 2 PWM mode 4 PWM mode 3 PWM mode 6 PWM mode pwm frequency config Arduino (8-bit) \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f (either 4kHz or 32kHz) Arduino DUE \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f stm32 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f esp32 MCPWM \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f esp32 LEDC \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f esp8266 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f samd21/51 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f teensy \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Raspberry Pi Pico \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Portenta H7 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f nRF52 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f <p>From this table you can see that if you need the 6 PWM mode for your application you should avoid using Teensy and Arduino DUE boards for now.</p> <p>Info</p> <p>For more details, please refer to the SimpleFOC Arduino library documentation.</p> <p>Arduino SimpleFOClibrary has a goal to support as many BLDC and stepper motor drivers as possible. Till this moment there are two kinds of motor drivers supported by this library:</p> <ul> <li>BLDC motor driver <ul> <li>3 PWM signals ( 3 phase )</li> <li>6 PWM signals ( 3 phase )</li> </ul> </li> </ul> Current Limitations <p>Before running any BLDC motor with the SimpleFOClibrary please make sure your hardware can handle the currents your motor requires. </p> <p>The simplest way to do it is by checking the motor phase resistance <code>R</code>. Either check the datasheet of your motor and search for the resistance value or measure it yourself using a multimeter. Then check the value of your power supply voltage <code>V_dc</code> and once when you have the values you can find the maximum current <code>I_max</code> value by calculating: <pre><code>I_max = V_dc/R\n</code></pre> Finally check the value of the maximum current <code>I_max</code> with the datasheet of your driver board. If the <code>I_max</code> is too high you can lower the power supply voltage <code>V_dc</code> in order prevent too high peaks of the current. If you are not able to change your power supply voltage you can limit the voltage set to motor in software.   <p>NOTE</p>     The equation above calculates the worst case maximum current <code>I_max</code> and in most cases calculated <code>I_max</code> is higher than the actual value. Maximum current depends both of the motor hardware such as winding configuration and the control algorithm. </p> <p>Tip</p> <p>While the TMC6300 isn't directly listed as part of the supported hardware for the SimpleFOC Arduino library, we have verified that is compatible with the library.</p> <p>Info</p> <p>For more details, please refer to the SimpleFOC Arduino library documentation.</p> <p>Arduino SimpleFOClibrary supports two types of BLDC motors:</p> <ul> <li> <p>BLDC motors</p> <ul> <li> <p>3 phase (3 wire):</p> Gimbal Motors <p>Gimbal motors will work basically with any BLDC motor driver, but since the high-performance drivers have current measurement circuits optimized for high currents you will not have any benefit of using them. Therefore low-power BLDC motor drivers will have comparable performance as the expensive high-power, high-performance drivers for gimbal motors. What is in my opinion very cool! \ud83d\ude03 This was one of the main motivations to start developing  SimpleFOCShield.</p> <p>Some of the characteristics of Gimbal motors are:</p> <ul> <li>High torque on low velocities</li> <li>Very smooth operation</li> <li>Internal resistance &gt;10\u03a9</li> <li>Currents up to 5A</li> </ul> <p>Gimbal motors are very versatile and their main benefit is very smooth operation on low speeds and high torque. They can be used in may different applications everywhere from being a high-quality replacement for your stepper motor or DC servo motor to very smooth camera gimbals and many different robotics applications. One of very interesting use cases are student experiments, where BLDC motors provide a very high degree of control and dynamics, such examples are ball and plate,  inverted pendulums, balancing robots and similar. </p> High-performance Motors <p>Gimbal motors are just a subset of all the BLDC motors there is. As suggested in previous chapters, when using high-torque ( currents &gt; 5A), low-resistance (~1\u03a9) BLDC motors such as drone motors make sure your BLDC driver can support the currents necessary. SimpleFOClibrary has been tested with several high performance BLDC drivers (supported BLDC drivers list). </p> </li> </ul> </li> <li> <p>Stepper motors</p> <ul> <li>2 phase (4 wire)</li> </ul> </li> </ul> Current Limitations <p>Before running any BLDC motor with the SimpleFOClibrary please make sure your hardware can handle the currents your motor requires. </p> <p>The simplest way to do it is by checking the motor phase resistance <code>R</code>. Either check the datasheet of your motor and search for the resistance value or measure it yourself using a multimeter. Then check the value of your power supply voltage <code>V_dc</code> and once when you have the values you can find the maximum current <code>I_max</code> value by calculating: <pre><code>I_max = V_dc/R\n</code></pre> Finally check the value of the maximum current <code>I_max</code> with the datasheet of your driver board. If the <code>I_max</code> is too high you can lower the power supply voltage <code>V_dc</code> in order prevent too high peaks of the current. If you are not able to change your power supply voltage you can limit the voltage set to motor in software.   <p>NOTE</p>     The equation above calculates the worst case maximum current <code>I_max</code> and in most cases calculated <code>I_max</code> is higher than the actual value. Maximum current depends both of the motor hardware such as winding configuration and the control algorithm. </p> <p>Info</p> <p>For more details, please refer to the SimpleFOC Arduino library documentation.</p>"},{"location":"print_view/#6pwm-motor-driver","title":"6PWM Motor Driver","text":"<p>Users will need to utilize the <code>BLDCDriver6PWM</code> class to provide the six PWM signals required for the TMC6300 motor driver.</p> <code>BLDCDriver6PWM</code> <p>This class provides an abstraction layer for most of the common BLDC drivers, which require six PWM signals. This method offers more control than a three PWM motor drivers, since each of the 6 half-bridges MOSFETs can be controlled independently.</p> <p>To create the interface to the BLDC driver you need to specify the 6 <code>PWM</code> pin numbers for each motor phase and optionally <code>enable</code> pin. <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\n//  - phA_h, phA_l - A phase pwm pin high/low pair \n//  - phB_h, phB_l - B phase pwm pin high/low pair\n//  - phB_h, phC_l - C phase pwm pin high/low pair\n//  - enable pin    - (optional input)\nBLDCDriver6PWM driver = BLDCDriver6PWM(5,6, 9,10, 3,11, 8);\n</code></pre></p> <p>Microcontroller Considerations</p> Arduino UnoSTM32ESP32 <p>Arduino UNO and all the atmega328 based boards have only 6 PWM pins and in order to use the <code>BLDCDrievr6PWM</code> we need to use all of them. Those are <code>3</code>,<code>5</code>,<code>6</code>,<code>9</code>,<code>10</code> and <code>11</code>.  Furthermore in order for the algorithm to work well we need to use the PWM pins that belong to the same timer for each high/low side pair of each phase. So Atmega328 pins belonging to the timers are:</p> <code>TIM0</code> <code>TIM1</code> <code>TIM2</code> <code>5</code>,<code>6</code> <code>9</code>,<code>10</code> <code>3</code>,<code>11</code> <p>Therefore it is important that <code>phA_h</code> and <code>phA_l</code> belong to one timer, <code>phB_h</code> and <code>phB_l</code> to second timer and <code>phC_h</code> and <code>phC_l</code> to the last timer. If we decide that phase <code>A</code> belongs to the timer <code>TIM0</code> we can set <code>phA_h</code> either to pin <code>5</code> or pin <code>6</code>. </p> <p>Stm32 boards have two possible 6 PWM modes:</p> <ul> <li>Hardware 6 PWM mode</li> <li>Software 6 PWM mode</li> </ul> <ul> <li> <p>Hardware PWM</p> <p>In hardware 6 PWM mode the user uses only one timer, usually Timer 1 for all the 6 PWM channels. Stm32 boards usually have at least one timer which has automatic complementary channels which avoids the need for a complicated channel inverting configuration. SimpleFOClibrary automatically enables this control mode if you provide the pins that support this interface to the constructor of the <code>BLDCDriver6PWM</code> class. For example, both STM32 Bluepill and STM32 Nucleo boards have this interface supported by pins:</p> <code>T1C1</code> <code>T1C2</code> <code>T1C3</code> <code>T1C1N</code> <code>T1C2N</code> <code>T1C3N</code> <code>PA8</code> <code>PA9</code> <code>PA10</code> <code>PB13</code> <code>PB14</code> <code>PB15</code> <p>Where <code>T1Cx</code> are the Timer 1 channels and <code>T1CxN</code> are their complementary channels (inverted channels). Each pair of <code>T1Cx</code> and <code>T1CxN</code> is used for one pair of the high/low PWM pins. The library will configure the necessary timers and registers if you provide these pins to the constrictor of the <code>BLDCDriver6PWM</code> class. For example: <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\nBLDCDriver6PWM driver = BLDCDriver6PWM(PA8, PB13, PA9, PB14, PA10, PB15);\n</code></pre></p> </li> <li> <p>Software PWM</p> <p>If it is not possible to use the hardware 6 PWM mode with your board  SimpleFOClibrary enables you to use any two channels of any of the timers as your high/low side PWM pair. Basically, the library will automatically configure the complementary channels on the provided low side pins. The only requirement for this code to work properly is exatcly the same as for the Arudino UNO, each phase high/low PWM pair needs to belong to the same timer.  For example, if we take STM32 Nucleo F401RE board we can take for example: <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\nBLDCDriver6PWM driver = BLDCDriver6PWM(7, 2, 6, 3, 5, 4);\n</code></pre> Where</p> <code>T1C1</code> <code>T1C3</code> <code>T2C3</code> <code>T2C2</code> <code>T3C1</code> <code>T3C2</code> <code>7</code> <code>2</code> <code>6</code> <code>3</code> <code>5</code> <code>4</code> <p>On Bluepill we could use: <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\nBLDCDriver6PWM driver = BLDCDriver6PWM(PA8, PA9, PB6, PB7, PB8, PB9);\n</code></pre> Where</p> <code>T1C1</code> <code>T1C2</code> <code>T4C1</code> <code>T4C2</code> <code>T4C3</code> <code>T4C4</code> <code>PA8</code> <code>PA9</code> <code>PB6</code> <code>PB7</code> <code>PB8</code> <code>PB9</code> </li> </ul> <p>ESP32 boards support <code>MCPWM</code> interface that is intended for this kind of applications. Each ESP32 board has two of the <code>MCPWM</code> channels and can support two 6 PWM drivers. There is no pin specific requirements for the ESP32, each pin can be used in PWM mode. But please make sure not to use the pins that have predefined states on boot because this could result malfunction. You can find this information online easily, here is a YouTube video with more details. </p> <p>Info</p> <p>For more details about the <code>BLDCDriver6PWM</code> class, check out the online documentation.</p>"},{"location":"print_view/#bldc-motor","title":"BLDC Motor","text":"<p>All BLDC motors are handled with the <code>BLDCMotor</code> class.</p> <code>BLDCMotor</code> <p>This class implements the BLDC FOC algorithm, motion control loops, and monitoring.</p> <p>To instantiate the BLDC motor we need to create an instance of the <code>BLDCMotor</code> class and provide it the number of <code>pole pairs</code> of the motor. <pre><code>//  BLDCMotor(int pp, (optional R, KV))\n//  - pp  - pole pair number\n//  - R   - phase resistance value - optional\n//  - KV  - motor KV rating [rpm/V] - optional\nBLDCMotor motor = BLDCMotor(11, 10.5, 120);\n</code></pre></p> <p>Motor Considerations</p> <p>While, the datasheet for our gimbal motor, indicates that there are 8 pole pairs, we have found that the motor operates more smoothly if the <code>BLDCMotor</code> class is instantiated with 7 pole pairs instead.</p> <pre><code>BLDCMotor motor = BLDCMotor(7);\n</code></pre> <p>Info</p> <p>For more details about the <code>BLDCMotor</code> class, check out the online documentation.</p>"},{"location":"print_view/#position-sensor","title":"Position Sensor","text":"<p>In order to incorporate the TMAG5273 hall-effect sensor into the FOC algorithm, users will need to utilize the <code>GenericSensor</code> class.</p> <code>GenericSensor</code> <p>This class allows users to link a custom position sensor (not already implemented in the SimpleFOC library) by incorporating a few functions into their sketch.</p> <ol> <li> <p>Implement two functions; one to initialize the TMAG5273 and another to read and return the sensor's current position.</p> <pre><code>void initMySensorCallback(){\n  // do the init\n}\n</code></pre> <pre><code>float readMySensorCallback(){\n // read my sensor\n // return the angle value in radians in between 0 and 2PI\n return ...;\n}\n</code></pre> </li> <li> <p>Instantiate the <code>GenericSensor</code> class and initialize the class by providing it pointers to the two functions.</p> <pre><code>// GenericSensor class constructor\n//  - readCallback pointer to the function reading the sensor angle\n//  - initCallback pointer to the function initialising the sensor (optional)\nGenericSensor sensor = GenericSensor(readMySensorCallback, initMySensorCallback);\n</code></pre> </li> <li> <p>There are two ways to use sensors implemented within the SimpleFOC library:</p> <ul> <li>As standalone position sensor<ul> <li>In this configuration users would simply read the sensor's position, independently from incorporating the readings into the FOC algorithm.</li> </ul> </li> <li> <p>Incorporate it as the motor position sensor for FOC algorithm</p> <ol> <li> <p>Initialize the sensor in the <code>setup()</code> loop:</p> <pre><code>void setup() {\n  // monitoring port\n  Serial.begin(115200);\n\n  // initialize sensor hardware\n  sensor.init();\n\n  Serial.println(\"My sensor ready\");\n  _delay(1000);\n}\n</code></pre> </li> <li> <p>Link the sensor in the <code>setup()</code> loop:</p> <pre><code>void setup() {\n   ....\n  // initialize sensor hardware\n  sensor.init();\n  // link to the motor\n  motor.linkSensor(&amp;sensor);\n  ...\n  motor.initFOC();\n  ...\n}\n</code></pre> </li> </ol> </li> </ul> </li> </ol> <p>Info</p> <p>For more instructions on incorporating the <code>GenericSensor</code> class, please refer to the SimpleFOC documentation.</p>"},{"location":"print_view/#in-line-current-sensing","title":"In-line Current Sensing","text":"<p>In order to incorporate the current sensing into the FOC algorithm, users will need to utilize the <code>InlineCurrentSense</code> class.</p> <code>InlineCurrentSense</code> <p>This class allows users to link a custom position sensor (not already implemented in the SimpleFOC library) by incorporating a few functions into their sketch.</p> <ol> <li> <p>Instantiate the <code>InlineCurrentSense</code> class and initialize the class by providing the hardware configuration.</p> <p>To instantiate the inline current sensor using the SimpleFOClibrary just create an instance of the class <code>InlineCurrentSense</code>.  ```cpp // InlineCurrentSensor constructor //  - shunt_resistor  - shunt resistor value //  - gain  - current-sense op-amp gain //  - phA   - A phase adc pin //  - phB   - B phase adc pin //  - phC   - C phase adc pin (optional) InlineCurrentSense current_sense  = InlineCurrentSense(0.01, 20, A0, A1, A2);</p> </li> <li> <p>Incorporate the current sensor into the FOC algorithm:</p> <ol> <li> <p>Initialize the sensor in the <code>setup()</code> loop:</p> <p>Once the current sense has been created it can be initialised. This <code>init()</code> function configures the ADC hardware for reading and finds the zero offsets of the ADC for each channel.  ```cpp // init current sense current_sense.init();</p> </li> <li> <p>Link the sensor to the motor driver in the <code>setup()</code> loop:</p> <p>To use the <code>InlineCurrentSense</code> with the FOC algorithm, first thing you'll need to do is to associate (link) your current sense with the <code>BLDCDriver</code>: ```cpp // link current sense and driver current_sense.linkDriver(&amp;driver);</p> </li> <li> <p>Link the sensor to the motor in the <code>setup()</code> loop:</p> <p>Once the driver is linked to the current sense, last step is to link the current sense with the <code>BLDCMotor</code> you wish to use it with: ```cpp // link motor and current sense motor.linkCurrentSense(&amp;current_sense);</p> </li> </ol> <p>It is very important that the the current sensing <code>init</code> function is called after the <code>BLDCMotor</code> and <code>BLDCDriver</code> init functions are called. Which will make sure that the driver is enabled when current sense calibration is taking place. Also, it is important that the current sense <code>init</code> function is called before starting the foc algorithm with the <code>initFOC</code> function.</p> <p>So the suggested code structure would be:</p> <p>```cpp void loop(){   ....    // driver init   driver.init();   // link the driver to the current sense   current_sense.linkDriver(&amp;driver);   ....   // motor init   motor.init();   ....    // init current sense   current_sense.init();   // link the current sense to the motor   motor.linkCurrentSense(&amp;current_sense);   ...   // start the FOC   motor.initFOC(); }</p> </li> </ol> <p>Info</p> <p>For instructions on incorporating the <code>InlineCurrentSense</code> class, please refer to the SimpleFOC documentation.</p>"},{"location":"print_view/#example-bldc","title":"Example - BLDC","text":"<p>In this example, users will be utilizing the TMC6300 motor driver to spin the motor.</p>"},{"location":"print_view/#example-code","title":"Example Code","text":"<p>After installing and setting up the Arduino IDE and the Simple FOC Arduino library, users will need to upload the following example code using the SparkFun ESP32 Thing Plus C board definition. This code can be copied or downloaded below:</p> <p>  Download <code>BLDC.ino</code> Example Code </p> <p>Example Code</p> BLDC.ino<pre><code>    // Open loop motor control example\n    #include &lt;SimpleFOC.h&gt;\n\n\n    // BLDC motor &amp; driver instance\n    // BLDCMotor motor = BLDCMotor(pole pair number);\n    BLDCMotor motor = BLDCMotor(7);\n    // BLDCDriver3PWM driver = BLDCDriver3PWM(pwmA, pwmB, pwmC, Enable(optional));\n    BLDCDriver6PWM driver = BLDCDriver6PWM(5, 6, 9,10, 3, 11);\n\n    // Stepper motor &amp; driver instance\n    //StepperMotor motor = StepperMotor(50);\n    //StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6,  8);\n\n\n    //target variable\n    float target_velocity = 6;\n\n    // // instantiate the commander\n    Commander command = Commander(Serial);\n    // void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    // void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    void setup() {\n\n      // driver config\n      // power supply voltage [V]\n      driver.voltage_power_supply = 5;\n      // limit the maximal dc voltage the driver can set\n      // as a protection measure for the low-resistance motors\n      // this value is fixed on startup\n      driver.voltage_limit = 5;\n      // pwm frequency to be used [Hz]\n      // for atmega328 fixed to 32kHz\n      // esp32/stm32/teensy configurable\n      driver.pwm_frequency = 32000;\n\n\n      driver.init();\n      // link the motor and the driver\n      motor.linkDriver(&amp;driver);\n\n      // limiting motor movements\n      // limit the voltage to be set to the motor\n      // start very low for high resistance motors\n      // current = voltage / resistance, so try to be well under 1Amp\n      motor.voltage_limit = 3;   // [V]\n\n      // open loop control config\n      motor.controller = MotionControlType::velocity_openloop;\n\n      // init motor hardware\n      motor.init();\n\n      // add target command T\n      // command.add('T', doTarget, \"target velocity\");\n      // command.add('L', doLimit, \"voltage limit\");\n\n      Serial.begin(115200);\n      Serial.println(\"Motor ready!\");\n      Serial.println(\"Set target velocity [rad/s]\");\n      _delay(1000);\n\n    }\n\n    void loop() {\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n\n    }\n</code></pre>"},{"location":"print_view/#running-the-motor","title":"Running the Motor","text":"<p>By default, the motor should spin automatically. However, if users wish to control the speed of the motor, they can uncomment lines 21-22 and 56-57 of code and reprogram the board.</p> Code Changes Highlighted <p>Uncomment the following lines of code (21-22 and 56-57):</p> BLDC.ino<pre><code>    // Open loop motor control example\n    #include &lt;SimpleFOC.h&gt;\n\n\n    // BLDC motor &amp; driver instance\n    // BLDCMotor motor = BLDCMotor(pole pair number);\n    BLDCMotor motor = BLDCMotor(7);\n    // BLDCDriver3PWM driver = BLDCDriver3PWM(pwmA, pwmB, pwmC, Enable(optional));\n    BLDCDriver6PWM driver = BLDCDriver6PWM(5, 6, 9,10, 3, 11);\n\n    // Stepper motor &amp; driver instance\n    //StepperMotor motor = StepperMotor(50);\n    //StepperDriver4PWM driver = StepperDriver4PWM(9, 5, 10, 6,  8);\n\n\n    //target variable\n    float target_velocity = 6;\n\n    // // instantiate the commander\n    Commander command = Commander(Serial);\n    // void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    // void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    void setup() {\n\n      // driver config\n      // power supply voltage [V]\n      driver.voltage_power_supply = 5;\n      // limit the maximal dc voltage the driver can set\n      // as a protection measure for the low-resistance motors\n      // this value is fixed on startup\n      driver.voltage_limit = 5;\n      // pwm frequency to be used [Hz]\n      // for atmega328 fixed to 32kHz\n      // esp32/stm32/teensy configurable\n      driver.pwm_frequency = 32000;\n\n\n      driver.init();\n      // link the motor and the driver\n      motor.linkDriver(&amp;driver);\n\n      // limiting motor movements\n      // limit the voltage to be set to the motor\n      // start very low for high resistance motors\n      // current = voltage / resistance, so try to be well under 1Amp\n      motor.voltage_limit = 3;   // [V]\n\n      // open loop control config\n      motor.controller = MotionControlType::velocity_openloop;\n\n      // init motor hardware\n      motor.init();\n\n      // add target command T\n      // command.add('T', doTarget, \"target velocity\");\n      // command.add('L', doLimit, \"voltage limit\");\n\n      Serial.begin(115200);\n      Serial.println(\"Motor ready!\");\n      Serial.println(\"Set target velocity [rad/s]\");\n      _delay(1000);\n\n    }\n\n    void loop() {\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n\n    }\n</code></pre> <p>In order to drive the motor, users will need to access the serial monitor and provide the commands necessary to drive the motor. A full list of the available commands can be found in the Simple FOC Arduino library documentation. However, only the <code>T</code> and <code>L</code> commands are enabled in the example code.</p> <ul> <li>Sending a <code>T</code> command will set the target motor velocity in rads/s<ul> <li>Example - Entering <code>T6</code> into the serial monitor, will set the target motor velocity to 6 radians/s.</li> </ul> </li> <li>Sending a <code>L</code> command will set the voltage limit of the motor driver and in turn, the current limit (voltage_limit / motor_resistance)<ul> <li>Example - Entering <code>L5</code> into the serial monitor, will set the voltage limit to 5V and the current limit to .5A (5V/10\u03a9).</li> </ul> </li> </ul> <p>Baud Rate</p> <p>The serial monitor baud rate should be configured to <code>115200bps</code>.</p>"},{"location":"print_view/#example-foc-algorithm","title":"Example - FOC Algorithm","text":""},{"location":"print_view/#example-factory-reset","title":"Example - Factory Reset","text":"<p>This example, allows users to reprogram their board with the same sketch that it comes pre-programmed with from SparkFun.</p>"},{"location":"print_view/#example-code_1","title":"Example Code","text":"<p>After installing and setting up the Arduino IDE and the Simple FOC Arduino library, users will need to upload the following example code using the SparkFun ESP32 Thing Plus C board definition. This code can be copied or downloaded below:</p> <p>  Download <code>IoT_MotorDriver.ino</code> Example Code </p> <p>Example Code</p> IoT_MotorDriver.ino<pre><code>    /******************************************************************************\n        IoT Motor Driver Example\n\n        Written By:\n            Madison Chodikov\n            Eric Orosel\n        Company: SparkFun Electronics   \n        Date: September 1 2023\n\n        This sketch is a stripped down version of the firmware that is preprogrammed\n        on the IoT Motor Driver. It is based on the open loop, velocity motor control\n        example from the SimpleFOC Arduino library.\n\n        This sketch will spin the motor based on the button inputs:\n            - Button 13: Starts/Stops the motor rotation\n            - Button 14: When spinning, switches the direction of rotation\n\n    ===============================================================================\n        Products:\n            IoT Brushless Motor Driver: https://www.sparkfun.com/products/22132\n\n        Repository:\n            https://github.com/sparkfun/SparkFun_IoT_Brushless_Motor_Driver\n    ===============================================================================\n\n        SparkFun code, firmware, and software is released under the MIT \n        License (http://opensource.org/licenses/MIT).\n\n        Distributed as-is; no warranty is given.\n    ******************************************************************************/\n\n    #include &lt;Wire.h&gt;\n    #include &lt;SimpleFOC.h&gt; //http://librarymanager/All#Simple%20FOC\n\n\n    //GPIO\n    #define auxBtn2   13\n    #define auxBtn1   14  \n\n    //driver\n    #define uh16      16\n    #define ul17      17\n    #define vh18      18\n    #define wh19      19\n    #define vl23      23\n    #define wl33      33\n    #define curSense  32\n\n    bool state = true;\n\n    //motor driver\n    BLDCMotor motor = BLDCMotor(7);\n    BLDCDriver6PWM driver = BLDCDriver6PWM(uh16, ul17, vh18, vl23, wh19, wl33,  curSense);\n    float target_velocity = 0.0;\n    Commander command = Commander(Serial);\n    void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    //////////////////////motor demo stuff///////////////////////////\n    struct Button{\n      const uint8_t PIN;\n      uint32_t numberKeyPresses;\n      bool pressed;\n    };\n    Button aux1 = {auxBtn1, 0, false};\n    Button aux2 = {auxBtn2, 0, false};\n\n    void IRAM_ATTR isr1(){\n      aux1.pressed = true;\n      target_velocity = target_velocity*(-1);\n      Serial.println(\"Changing directions.. \");\n    }\n\n    void IRAM_ATTR isr2(){\n      aux2.numberKeyPresses++;\n      aux2.pressed = true;\n\n      if((aux2.numberKeyPresses % 2) == 0)\n      {\n        target_velocity = 0;\n        Serial.println(\"Stopping motor.. \");\n      }\n      else\n      {\n        target_velocity = 5;\n        motor.enable();\n        Serial.println(\"Starting motor.. \");\n      }\n    }\n\n\n    void setup() {\n\n      //motor demo stuff\n      driver.voltage_power_supply = 3.3;\n      driver.pwm_frequency = 20000;\n      driver.voltage_limit = 4;\n      driver.init();\n      motor.linkDriver(&amp;driver);\n      motor.voltage_limit = 4;\n      motor.controller = MotionControlType::velocity_openloop;\n      motor.init();\n      motor.disable();\n      pinMode(aux1.PIN, INPUT_PULLUP); // Sets pin 14 on the ESP32 as an interrupt\n      attachInterrupt(aux1.PIN, isr1, FALLING); // Triggers when aux1 is pulled to GND (button pressed)\n      pinMode(aux2.PIN, INPUT_PULLUP); // Sets pin 13 on the ESP32 as an interrupt\n      attachInterrupt(aux2.PIN, isr2, FALLING); // Triggers when aux2 is pulled to GND (button pressed)\n      delay(100);\n\n      Serial.begin(115200);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    void loop() { \n\n      // Button Press ISR\n      if(aux1.pressed){ \n        aux1.pressed = false;\n      }\n\n      // Turning motor on and off\n      if(aux2.pressed){ \n        aux2.pressed = false;\n      }\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      // Basic motor movement\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n      delay(5);\n    }\n</code></pre>"},{"location":"print_view/#running-the-motor_1","title":"Running the Motor","text":"<p>By default, the motor should be disabled and spin freely. Users can utilize the user buttons 13 and 14 to control the motor.</p> <ul> <li>13 - Starts and stops the motor spin</li> <li>14 - Reverses the direction of the motor's rotation, when it is spinning</li> </ul> <p>Motor Overheating</p> <p>When the motor is stopped, the motor driver is still enabled. Therefore, current is still running through the stator coils and holding the motor in place. After a few minutes, users may notice that the motor begins to heat up a bit.</p> <p>If this becomes an issue, users can modify their code to disable the motor driver when the motor stops. This will prevent the motor from heating up, but the motor will spin freely as the motor driver is no longer engaged.</p> Modification <p>Modify the sketch and insert <code>motor.disable();</code> between lines <code>80</code> - <code>81</code>.</p> DC.ino<pre><code>    /******************************************************************************\n        IoT Motor Driver Example\n\n        Written By:\n            Madison Chodikov\n            Eric Orosel\n        Company: SparkFun Electronics   \n        Date: September 1 2023\n\n        This sketch is a stripped down version of the firmware that is preprogrammed\n        on the IoT Motor Driver. It is based on the open loop, velocity motor control\n        example from the SimpleFOC Arduino library.\n\n        This sketch will spin the motor based on the button inputs:\n            - Button 13: Starts/Stops the motor rotation\n            - Button 14: When spinning, switches the direction of rotation\n\n    ===============================================================================\n        Products:\n            IoT Brushless Motor Driver: https://www.sparkfun.com/products/22132\n\n        Repository:\n            https://github.com/sparkfun/SparkFun_IoT_Brushless_Motor_Driver\n    ===============================================================================\n\n        SparkFun code, firmware, and software is released under the MIT \n        License (http://opensource.org/licenses/MIT).\n\n        Distributed as-is; no warranty is given.\n    ******************************************************************************/\n\n    #include &lt;Wire.h&gt;\n    #include &lt;SimpleFOC.h&gt; //http://librarymanager/All#Simple%20FOC\n\n\n    //GPIO\n    #define auxBtn2   13\n    #define auxBtn1   14  \n\n    //driver\n    #define uh16      16\n    #define ul17      17\n    #define vh18      18\n    #define wh19      19\n    #define vl23      23\n    #define wl33      33\n    #define curSense  32\n\n    bool state = true;\n\n    //motor driver\n    BLDCMotor motor = BLDCMotor(7);\n    BLDCDriver6PWM driver = BLDCDriver6PWM(uh16, ul17, vh18, vl23, wh19, wl33,  curSense);\n    float target_velocity = 0.0;\n    Commander command = Commander(Serial);\n    void doTarget(char* cmd) { command.scalar(&amp;target_velocity, cmd); }\n    void doLimit(char* cmd) { command.scalar(&amp;motor.voltage_limit, cmd); }\n\n    //////////////////////motor demo stuff///////////////////////////\n    struct Button{\n      const uint8_t PIN;\n      uint32_t numberKeyPresses;\n      bool pressed;\n    };\n    Button aux1 = {auxBtn1, 0, false};\n    Button aux2 = {auxBtn2, 0, false};\n\n    void IRAM_ATTR isr1(){\n      aux1.pressed = true;\n      target_velocity = target_velocity*(-1);\n      Serial.println(\"Changing directions.. \");\n    }\n\n    void IRAM_ATTR isr2(){\n      aux2.numberKeyPresses++;\n      aux2.pressed = true;\n\n      if((aux2.numberKeyPresses % 2) == 0)\n      {\n        target_velocity = 0;\n        Serial.println(\"Stopping motor.. \");\n      }\n      else\n      {\n        target_velocity = 5;\n        motor.enable();\n        Serial.println(\"Starting motor.. \");\n      }\n    }\n\n\n    void setup() {\n\n      //motor demo stuff\n      driver.voltage_power_supply = 3.3;\n      driver.pwm_frequency = 20000;\n      driver.voltage_limit = 4;\n      driver.init();\n      motor.linkDriver(&amp;driver);\n      motor.voltage_limit = 4;\n      motor.controller = MotionControlType::velocity_openloop;\n      motor.init();\n      motor.disable();\n      pinMode(aux1.PIN, INPUT_PULLUP); // Sets pin 14 on the ESP32 as an interrupt\n      attachInterrupt(aux1.PIN, isr1, FALLING); // Triggers when aux1 is pulled to GND (button pressed)\n      pinMode(aux2.PIN, INPUT_PULLUP); // Sets pin 13 on the ESP32 as an interrupt\n      attachInterrupt(aux2.PIN, isr2, FALLING); // Triggers when aux2 is pulled to GND (button pressed)\n      delay(100);\n\n      Serial.begin(115200);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    void loop() { \n\n      // Button Press ISR\n      if(aux1.pressed){ \n        aux1.pressed = false;\n      }\n\n      // Turning motor on and off\n      if(aux2.pressed){ \n        aux2.pressed = false;\n      }\n\n      // open loop velocity movement\n      // using motor.voltage_limit and motor.velocity_limit\n      // Basic motor movement\n      motor.move(target_velocity);\n\n      // user communication\n      command.run();\n\n      delay(5);\n    }\n</code></pre>"},{"location":"print_view/#troubleshooting-tips","title":"Troubleshooting Tips","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search product forums and ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"print_view/#esp32-compile-error","title":"ESP32 Compile Error","text":"<p>If users run into an error similar to, <code>fatal error: soc/soc_caps.h: No such file or directory</code>, it may be due to an issue with the version of the ESP32 Arduino core that is installed in the Boards Manager. Users should make sure the have the latest version of the ESP32 Arduino core installed; or at least a version later than <code>v2.0.1</code>.</p> <p>Info</p> <p>For more information, please reference this forum post for the Simple FOC Arduino library.</p>"},{"location":"print_view/#resources","title":"Resources:","text":""},{"location":"print_view/#product-resources","title":"Product Resources","text":"<ul> <li> Product Page</li> <li>Component Documentation<ul> <li> ESP32 Module Datasheet</li> <li> TMC6300 Datasheet</li> <li> TMAG5273 Datasheet</li> <li> INA240 Datasheet</li> <li> WS2812 Datasheet</li> </ul> </li> <li> Design Files:<ul> <li> Board Dimensions</li> <li> Schematic</li> <li> Eagle Files</li> </ul> </li> <li>Arduino Library:<ul> <li> Simple FOC</li> <li> Documentation<ul> <li>Installation</li> <li>Supported Hardware</li> <li>Code Overview</li> </ul> </li> </ul> </li> <li> SFE Product Showcase</li> <li> Hardware Repo</li> </ul>"},{"location":"print_view/#additional-resources","title":"Additional Resources","text":"<ul> <li>Motors and Motor Driver Product Category</li> <li> SparkFun Technical Assistance</li> </ul>"},{"location":"print_view/#manufacturers-resources","title":"\ud83c\udfed\u00a0Manufacturer's Resources","text":"<p>Analog Devices + Trinamic also provides great resources for the TMC6300 motor driver:</p> <ul> <li>TMC6300 Product Page<ul> <li>Block Diagram/Pinout</li> <li> Datasheet</li> <li> Application Notes</li> </ul> </li> <li> Trinamic: TMC6300 Product Training Module</li> <li> Technical Support Page</li> </ul> <p> </p>"},{"location":"print_view/#background-resources","title":"Background Resources","text":"<p>Below, are several articles, application notes, and other technical resources on 3-phase motors and utilizing a field-oriented control (FOC) scheme:</p> <ul> <li>Microchip Technology<ul> <li>AN885: Brushless DC (BLDC) Motor Fundamentals</li> <li>AN2757: Sensored (Encoder-Based) Field-Oriented Control of Three-Phase Permanent Magnet Synchronous Motor (PMSM)</li> <li>AN1078: Sensorless Field-Oriented Control of a PMSM</li> <li>AVR32723: Sensor Field-Oriented Control for Brushless DC motors with AT32UC3B0256</li> </ul> </li> <li>Diodes Incorporated<ul> <li>AN1164: Introduction to Brushless DC Motors</li> </ul> </li> <li>Monolithic Power Systems<ul> <li>AN047: Brushless DC Motor Fundamentals</li> </ul> </li> <li>Texas Instruments<ul> <li>Demystifying BLDC motor commutation: Trap, Sine, &amp; FOC</li> <li>Sensored Field-Oriented Control of 3-Phase Permanent Magnet Synchronous Motors</li> <li>Sensorless Field-Oriented Control of 3-Phase Permanent Magnet Synchronous Motors</li> <li>Brushless-DC Motor Driver Considerations and Selection Guide</li> <li>High-Performance Brushless DC Motor Control</li> <li> Field-oriented control of permanent magnet synchronous motors</li> <li> Field-Oriented Control of Permanent Magnet Motors<ul> <li> Field-Oriented Control of Permanent Magnet Motors</li> </ul> </li> </ul> </li> <li>MATLAB<ul> <li> Motor Control, Part 4: Understanding Field-Oriented Control</li> </ul> </li> <li>Analog Devices + Trinamic<ul> <li>FOC As Hardware Building Block</li> </ul> </li> <li>Infineon Technologies<ul> <li>Motor Handbook</li> <li>AN204469 - FM3 Family 3-Phase PMSM FOC Control</li> <li>Block commutation vs. FOC in power tool motor control</li> <li> Motor control for BLDC: block commutation vs. field-oriented control</li> </ul> </li> <li>ST Microelectronics<ul> <li>AN5397: Current Sensing in Motion Control Applications</li> <li>AN4220: Sensorless Six-Step BLDC Commutation</li> </ul> </li> </ul>"},{"location":"resources/","title":"Hardware Resources","text":""},{"location":"resources/#product-resources","title":"Product Resources","text":"<ul> <li> Product Page</li> <li>Component Documentation<ul> <li> ESP32 Module Datasheet</li> <li> TMC6300 Datasheet</li> <li> TMAG5273 Datasheet</li> <li> INA240 Datasheet</li> <li> WS2812 Datasheet</li> </ul> </li> <li> Design Files:<ul> <li> Board Dimensions</li> <li> Schematic</li> <li> Eagle Files</li> </ul> </li> <li>Arduino Library:<ul> <li> Simple FOC</li> <li> Documentation<ul> <li>Installation</li> <li>Supported Hardware</li> <li>Code Overview</li> </ul> </li> </ul> </li> <li> SFE Product Showcase</li> <li> Hardware Repo</li> </ul>"},{"location":"resources/#additional-resources","title":"Additional Resources","text":"<ul> <li>Motors and Motor Driver Product Category</li> <li> SparkFun Technical Assistance</li> </ul>"},{"location":"resources/#manufacturers-resources","title":"\ud83c\udfed\u00a0Manufacturer's Resources","text":"<p>Analog Devices + Trinamic also provides great resources for the TMC6300 motor driver:</p> <ul> <li>TMC6300 Product Page<ul> <li>Block Diagram/Pinout</li> <li> Datasheet</li> <li> Application Notes</li> </ul> </li> <li> Trinamic: TMC6300 Product Training Module</li> <li> Technical Support Page</li> </ul> <p> </p>"},{"location":"software_overview/","title":"Installation & Setup","text":""},{"location":"software_overview/#ch340-driver","title":"CH340 Driver","text":"<p>Users will need to install the appropriate driver for their computer to recognize the serial-to-UART chip on their board/adapter. Most of the latest operating systems will recognize the CH340C chip on the board and automatically install the required driver.</p> <p>To manually install the CH340 driver on their computer, users can download it from the WCH website. For more information, check out our How to Install CH340 Drivers Tutorial.</p> <p></p> <p>How to Install CH340 Drivers</p>"},{"location":"software_overview/#arduino-ide","title":"Arduino IDE","text":"<p>Tip</p> <p>For first-time users, who have never programmed before and are looking to use the Arduino IDE, we recommend beginning with the SparkFun Inventor's Kit (SIK), which is designed to help users get started programming with the Arduino IDE.</p> <p>Most users may already be familiar with the Arduino IDE and its use. However, for those of you who have never heard the name Arduino before, feel free to check out the Arduino website. To get started with using the Arduino IDE, check out our tutorials below:</p> <ul> <li> <p> <p>What is an Arduino?</p> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p>"},{"location":"software_overview/#install-board-definition","title":"Install Board Definition","text":"<p>Install the latest ESP32 board definitions in the Arduino IDE.</p> <p> Installing Board Definitions in the Arduino IDE </p> <p>Info</p> <p>For more instructions, users can follow this tutorial on Installing Additional Cores provided by Arduino. Users will also need the <code>.json</code> file for the Espressif Arduino core:</p> <pre><code>https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json\n</code></pre> <p>When selecting a board to program in the Arduino IDE, users should select the SparkFun ESP32 Thing Plus C from the <code>Tools</code> drop-down menu (_i.e. Tools &gt; Board &gt; ESP32 Arduino &gt; SparkFun ESP32 Thing Plus C). Alternatively, users can also select the ESP32 Dev Module; however, they may lose some pin assignments.</p> <p></p> <p>Select the SparkFun ESP32 Thing Plus C from the <code>Tools</code> drop-down menu in the Arduino IDE.</p> Arduino IDE 2.x.x - Alternative Method <p>In the newest version of the Arduino IDE 2.<code>x</code>.<code>x</code>, users can also select their board (green) and port (blue) from the <code>Select Board &amp; Port</code> dropdown menu (yellow).</p> <p> Selecting the SparkFun ESP32 Thing Plus C and COM5 port from the Select Board &amp; Port drop-down menu in the Arduino IDE (v2.0.3). </p>"},{"location":"software_overview/#sparkfun-tmag5273-arduino-library","title":"SparkFun TMAG5273 Arduino Library","text":"<p>The SparkFun TMAG5273 Arduino Library can be installed from the library manager in the Arduino IDE.</p> <p></p> <p>SparkFun TMAG5273 Arduino library in the library manager of the Arduino IDE.</p> Arduino IDE (v1.x.x) <p>In the Arduino IDE v1.x.x, the library manager will have the following appearance for the SimpleFOC library:</p> <p> SparkFun TMAG5273 Arduino library in the library managerof the Arduino IDE (v1.x.x). </p> <p>This library will be primarily used to interact with the TMAG5273 hall-effect sensor and return the rotation angle of the motor.</p>"},{"location":"software_overview/#simplefoc-arduino-library","title":"SimpleFOC Arduino Library","text":"<p>The Simple Field Oriented Control Library can be installed from the library manager in the Arduino IDE.</p> <p></p> <p>SimpleFOC library in the library manager of the Arduino IDE.</p> Arduino IDE (v1.x.x) <p>In the Arduino IDE v1.x.x, the library manager will have the following appearance for the SimpleFOC library:</p> <p> SimpleFOC library in the library manager of the Arduino IDE (v1.x.x). </p> <p>This library utilizes a motor control scheme called field oriented control (FOC), which can utilize a feedback control loop to drive a motor with a higher power efficiency and precision characteristics, like evenly distributed torque control.</p> <p>Info</p> <p>For more details about the library, check out the online documentation.</p> <p>Supported Hardware</p> <p>For a detailed and up-to-date list of the hardware supported by this library, check out the library's documentation. The following are excerpts taken from the library's documentation page:</p> MicrocontrollersMotor DriversMotors <p>Arduino SimpleFOClibrary supports:</p> MCU 2 PWM mode 4 PWM mode 3 PWM mode 6 PWM mode pwm frequency config Arduino (8-bit) \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f (either 4kHz or 32kHz) Arduino DUE \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f stm32 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f esp32 MCPWM \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f esp32 LEDC \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f esp8266 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f samd21/51 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f teensy \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Raspberry Pi Pico \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Portenta H7 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f nRF52 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f <p>From this table you can see that if you need the 6 PWM mode for your application you should avoid using Teensy and Arduino DUE boards for now.</p> <p>Info</p> <p>For more details, please refer to the SimpleFOC Arduino library documentation.</p> <p>Arduino SimpleFOClibrary has a goal to support as many BLDC and stepper motor drivers as possible. Till this moment there are two kinds of motor drivers supported by this library:</p> <ul> <li>BLDC motor driver <ul> <li>3 PWM signals ( 3 phase )</li> <li>6 PWM signals ( 3 phase )</li> </ul> </li> </ul> Current Limitations <p>Before running any BLDC motor with the SimpleFOClibrary please make sure your hardware can handle the currents your motor requires. </p> <p>The simplest way to do it is by checking the motor phase resistance <code>R</code>. Either check the datasheet of your motor and search for the resistance value or measure it yourself using a multimeter. Then check the value of your power supply voltage <code>V_dc</code> and once when you have the values you can find the maximum current <code>I_max</code> value by calculating: <pre><code>I_max = V_dc/R\n</code></pre> Finally check the value of the maximum current <code>I_max</code> with the datasheet of your driver board. If the <code>I_max</code> is too high you can lower the power supply voltage <code>V_dc</code> in order prevent too high peaks of the current. If you are not able to change your power supply voltage you can limit the voltage set to motor in software.   <p>NOTE</p>     The equation above calculates the worst case maximum current <code>I_max</code> and in most cases calculated <code>I_max</code> is higher than the actual value. Maximum current depends both of the motor hardware such as winding configuration and the control algorithm. </p> <p>Tip</p> <p>While the TMC6300 isn't directly listed as part of the supported hardware for the SimpleFOC Arduino library, we have verified that is compatible with the library.</p> <p>Info</p> <p>For more details, please refer to the SimpleFOC Arduino library documentation.</p> <p>Arduino SimpleFOClibrary supports two types of BLDC motors:</p> <ul> <li> <p>BLDC motors</p> <ul> <li> <p>3 phase (3 wire):</p> Gimbal Motors <p>Gimbal motors will work basically with any BLDC motor driver, but since the high-performance drivers have current measurement circuits optimized for high currents you will not have any benefit of using them. Therefore low-power BLDC motor drivers will have comparable performance as the expensive high-power, high-performance drivers for gimbal motors. What is in my opinion very cool! \ud83d\ude03 This was one of the main motivations to start developing  SimpleFOCShield.</p> <p>Some of the characteristics of Gimbal motors are:</p> <ul> <li>High torque on low velocities</li> <li>Very smooth operation</li> <li>Internal resistance &gt;10\u03a9</li> <li>Currents up to 5A</li> </ul> <p>Gimbal motors are very versatile and their main benefit is very smooth operation on low speeds and high torque. They can be used in may different applications everywhere from being a high-quality replacement for your stepper motor or DC servo motor to very smooth camera gimbals and many different robotics applications. One of very interesting use cases are student experiments, where BLDC motors provide a very high degree of control and dynamics, such examples are ball and plate,  inverted pendulums, balancing robots and similar. </p> High-performance Motors <p>Gimbal motors are just a subset of all the BLDC motors there is. As suggested in previous chapters, when using high-torque ( currents &gt; 5A), low-resistance (~1\u03a9) BLDC motors such as drone motors make sure your BLDC driver can support the currents necessary. SimpleFOClibrary has been tested with several high performance BLDC drivers (supported BLDC drivers list). </p> </li> </ul> </li> <li> <p>Stepper motors</p> <ul> <li>2 phase (4 wire)</li> </ul> </li> </ul> Current Limitations <p>Before running any BLDC motor with the SimpleFOClibrary please make sure your hardware can handle the currents your motor requires. </p> <p>The simplest way to do it is by checking the motor phase resistance <code>R</code>. Either check the datasheet of your motor and search for the resistance value or measure it yourself using a multimeter. Then check the value of your power supply voltage <code>V_dc</code> and once when you have the values you can find the maximum current <code>I_max</code> value by calculating: <pre><code>I_max = V_dc/R\n</code></pre> Finally check the value of the maximum current <code>I_max</code> with the datasheet of your driver board. If the <code>I_max</code> is too high you can lower the power supply voltage <code>V_dc</code> in order prevent too high peaks of the current. If you are not able to change your power supply voltage you can limit the voltage set to motor in software.   <p>NOTE</p>     The equation above calculates the worst case maximum current <code>I_max</code> and in most cases calculated <code>I_max</code> is higher than the actual value. Maximum current depends both of the motor hardware such as winding configuration and the control algorithm. </p> <p>Info</p> <p>For more details, please refer to the SimpleFOC Arduino library documentation.</p>"},{"location":"software_overview/#6pwm-motor-driver","title":"6PWM Motor Driver","text":"<p>Users will need to utilize the <code>BLDCDriver6PWM</code> class to provide the six PWM signals required for the TMC6300 motor driver.</p> <code>BLDCDriver6PWM</code> <p>This class provides an abstraction layer for most of the common BLDC drivers, which require six PWM signals. This method offers more control than a three PWM motor drivers, since each of the 6 half-bridges MOSFETs can be controlled independently.</p> <p>To create the interface to the BLDC driver you need to specify the 6 <code>PWM</code> pin numbers for each motor phase and optionally <code>enable</code> pin. <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\n//  - phA_h, phA_l - A phase pwm pin high/low pair \n//  - phB_h, phB_l - B phase pwm pin high/low pair\n//  - phB_h, phC_l - C phase pwm pin high/low pair\n//  - enable pin    - (optional input)\nBLDCDriver6PWM driver = BLDCDriver6PWM(5,6, 9,10, 3,11, 8);\n</code></pre></p> <p>Microcontroller Considerations</p> Arduino UnoSTM32ESP32 <p>Arduino UNO and all the atmega328 based boards have only 6 PWM pins and in order to use the <code>BLDCDrievr6PWM</code> we need to use all of them. Those are <code>3</code>,<code>5</code>,<code>6</code>,<code>9</code>,<code>10</code> and <code>11</code>.  Furthermore in order for the algorithm to work well we need to use the PWM pins that belong to the same timer for each high/low side pair of each phase. So Atmega328 pins belonging to the timers are:</p> <code>TIM0</code> <code>TIM1</code> <code>TIM2</code> <code>5</code>,<code>6</code> <code>9</code>,<code>10</code> <code>3</code>,<code>11</code> <p>Therefore it is important that <code>phA_h</code> and <code>phA_l</code> belong to one timer, <code>phB_h</code> and <code>phB_l</code> to second timer and <code>phC_h</code> and <code>phC_l</code> to the last timer. If we decide that phase <code>A</code> belongs to the timer <code>TIM0</code> we can set <code>phA_h</code> either to pin <code>5</code> or pin <code>6</code>. </p> <p>Stm32 boards have two possible 6 PWM modes:</p> <ul> <li>Hardware 6 PWM mode</li> <li>Software 6 PWM mode</li> </ul> <ul> <li> <p>Hardware PWM</p> <p>In hardware 6 PWM mode the user uses only one timer, usually Timer 1 for all the 6 PWM channels. Stm32 boards usually have at least one timer which has automatic complementary channels which avoids the need for a complicated channel inverting configuration. SimpleFOClibrary automatically enables this control mode if you provide the pins that support this interface to the constructor of the <code>BLDCDriver6PWM</code> class. For example, both STM32 Bluepill and STM32 Nucleo boards have this interface supported by pins:</p> <code>T1C1</code> <code>T1C2</code> <code>T1C3</code> <code>T1C1N</code> <code>T1C2N</code> <code>T1C3N</code> <code>PA8</code> <code>PA9</code> <code>PA10</code> <code>PB13</code> <code>PB14</code> <code>PB15</code> <p>Where <code>T1Cx</code> are the Timer 1 channels and <code>T1CxN</code> are their complementary channels (inverted channels). Each pair of <code>T1Cx</code> and <code>T1CxN</code> is used for one pair of the high/low PWM pins. The library will configure the necessary timers and registers if you provide these pins to the constrictor of the <code>BLDCDriver6PWM</code> class. For example: <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\nBLDCDriver6PWM driver = BLDCDriver6PWM(PA8, PB13, PA9, PB14, PA10, PB15);\n</code></pre></p> </li> <li> <p>Software PWM</p> <p>If it is not possible to use the hardware 6 PWM mode with your board  SimpleFOClibrary enables you to use any two channels of any of the timers as your high/low side PWM pair. Basically, the library will automatically configure the complementary channels on the provided low side pins. The only requirement for this code to work properly is exatcly the same as for the Arudino UNO, each phase high/low PWM pair needs to belong to the same timer.  For example, if we take STM32 Nucleo F401RE board we can take for example: <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\nBLDCDriver6PWM driver = BLDCDriver6PWM(7, 2, 6, 3, 5, 4);\n</code></pre> Where</p> <code>T1C1</code> <code>T1C3</code> <code>T2C3</code> <code>T2C2</code> <code>T3C1</code> <code>T3C2</code> <code>7</code> <code>2</code> <code>6</code> <code>3</code> <code>5</code> <code>4</code> <p>On Bluepill we could use: <pre><code>//  BLDCDriver6PWM( int phA_h, int phA_l, int phB_h, int phB_l, int phC_h, int phC_l, int en)\nBLDCDriver6PWM driver = BLDCDriver6PWM(PA8, PA9, PB6, PB7, PB8, PB9);\n</code></pre> Where</p> <code>T1C1</code> <code>T1C2</code> <code>T4C1</code> <code>T4C2</code> <code>T4C3</code> <code>T4C4</code> <code>PA8</code> <code>PA9</code> <code>PB6</code> <code>PB7</code> <code>PB8</code> <code>PB9</code> </li> </ul> <p>ESP32 boards support <code>MCPWM</code> interface that is intended for this kind of applications. Each ESP32 board has two of the <code>MCPWM</code> channels and can support two 6 PWM drivers. There is no pin specific requirements for the ESP32, each pin can be used in PWM mode. But please make sure not to use the pins that have predefined states on boot because this could result malfunction. You can find this information online easily, here is a YouTube video with more details. </p> <p>Info</p> <p>For more details about the <code>BLDCDriver6PWM</code> class, check out the online documentation.</p>"},{"location":"software_overview/#bldc-motor","title":"BLDC Motor","text":"<p>All BLDC motors are handled with the <code>BLDCMotor</code> class.</p> <code>BLDCMotor</code> <p>This class implements the BLDC FOC algorithm, motion control loops, and monitoring.</p> <p>To instantiate the BLDC motor we need to create an instance of the <code>BLDCMotor</code> class and provide it the number of <code>pole pairs</code> of the motor. <pre><code>//  BLDCMotor(int pp, (optional R, KV))\n//  - pp  - pole pair number\n//  - R   - phase resistance value - optional\n//  - KV  - motor KV rating [rpm/V] - optional\nBLDCMotor motor = BLDCMotor(11, 10.5, 120);\n</code></pre></p> <p>Motor Considerations</p> <p>While, the datasheet for our gimbal motor, indicates that there are 8 pole pairs, we have found that the motor operates more smoothly if the <code>BLDCMotor</code> class is instantiated with 7 pole pairs instead.</p> <pre><code>BLDCMotor motor = BLDCMotor(7);\n</code></pre> <p>Info</p> <p>For more details about the <code>BLDCMotor</code> class, check out the online documentation.</p>"},{"location":"software_overview/#position-sensor","title":"Position Sensor","text":"<p>In order to incorporate the TMAG5273 hall-effect sensor into the FOC algorithm, users will need to utilize the <code>GenericSensor</code> class.</p> <code>GenericSensor</code> <p>This class allows users to link a custom position sensor (not already implemented in the SimpleFOC library) by incorporating a few functions into their sketch.</p> <ol> <li> <p>Implement two functions; one to initialize the TMAG5273 and another to read and return the sensor's current position.</p> <pre><code>void initMySensorCallback(){\n  // do the init\n}\n</code></pre> <pre><code>float readMySensorCallback(){\n // read my sensor\n // return the angle value in radians in between 0 and 2PI\n return ...;\n}\n</code></pre> </li> <li> <p>Instantiate the <code>GenericSensor</code> class and initialize the class by providing it pointers to the two functions.</p> <pre><code>// GenericSensor class constructor\n//  - readCallback pointer to the function reading the sensor angle\n//  - initCallback pointer to the function initialising the sensor (optional)\nGenericSensor sensor = GenericSensor(readMySensorCallback, initMySensorCallback);\n</code></pre> </li> <li> <p>There are two ways to use sensors implemented within the SimpleFOC library:</p> <ul> <li>As standalone position sensor<ul> <li>In this configuration users would simply read the sensor's position, independently from incorporating the readings into the FOC algorithm.</li> </ul> </li> <li> <p>Incorporate it as the motor position sensor for FOC algorithm</p> <ol> <li> <p>Initialize the sensor in the <code>setup()</code> loop:</p> <pre><code>void setup() {\n  // monitoring port\n  Serial.begin(115200);\n\n  // initialize sensor hardware\n  sensor.init();\n\n  Serial.println(\"My sensor ready\");\n  _delay(1000);\n}\n</code></pre> </li> <li> <p>Link the sensor in the <code>setup()</code> loop:</p> <pre><code>void setup() {\n   ....\n  // initialize sensor hardware\n  sensor.init();\n  // link to the motor\n  motor.linkSensor(&amp;sensor);\n  ...\n  motor.initFOC();\n  ...\n}\n</code></pre> </li> </ol> </li> </ul> </li> </ol> <p>Info</p> <p>For more instructions on incorporating the <code>GenericSensor</code> class, please refer to the SimpleFOC documentation.</p>"},{"location":"software_overview/#in-line-current-sensing","title":"In-line Current Sensing","text":"<p>In order to incorporate the current sensing into the FOC algorithm, users will need to utilize the <code>InlineCurrentSense</code> class.</p> <code>InlineCurrentSense</code> <p>This class allows users to link a custom position sensor (not already implemented in the SimpleFOC library) by incorporating a few functions into their sketch.</p> <ol> <li> <p>Instantiate the <code>InlineCurrentSense</code> class and initialize the class by providing the hardware configuration.</p> <p>To instantiate the inline current sensor using the SimpleFOClibrary just create an instance of the class <code>InlineCurrentSense</code>.  ```cpp // InlineCurrentSensor constructor //  - shunt_resistor  - shunt resistor value //  - gain  - current-sense op-amp gain //  - phA   - A phase adc pin //  - phB   - B phase adc pin //  - phC   - C phase adc pin (optional) InlineCurrentSense current_sense  = InlineCurrentSense(0.01, 20, A0, A1, A2);</p> </li> <li> <p>Incorporate the current sensor into the FOC algorithm:</p> <ol> <li> <p>Initialize the sensor in the <code>setup()</code> loop:</p> <p>Once the current sense has been created it can be initialised. This <code>init()</code> function configures the ADC hardware for reading and finds the zero offsets of the ADC for each channel.  ```cpp // init current sense current_sense.init();</p> </li> <li> <p>Link the sensor to the motor driver in the <code>setup()</code> loop:</p> <p>To use the <code>InlineCurrentSense</code> with the FOC algorithm, first thing you'll need to do is to associate (link) your current sense with the <code>BLDCDriver</code>: ```cpp // link current sense and driver current_sense.linkDriver(&amp;driver);</p> </li> <li> <p>Link the sensor to the motor in the <code>setup()</code> loop:</p> <p>Once the driver is linked to the current sense, last step is to link the current sense with the <code>BLDCMotor</code> you wish to use it with: ```cpp // link motor and current sense motor.linkCurrentSense(&amp;current_sense);</p> </li> </ol> <p>It is very important that the the current sensing <code>init</code> function is called after the <code>BLDCMotor</code> and <code>BLDCDriver</code> init functions are called. Which will make sure that the driver is enabled when current sense calibration is taking place. Also, it is important that the current sense <code>init</code> function is called before starting the foc algorithm with the <code>initFOC</code> function.</p> <p>So the suggested code structure would be:</p> <p>```cpp void loop(){   ....    // driver init   driver.init();   // link the driver to the current sense   current_sense.linkDriver(&amp;driver);   ....   // motor init   motor.init();   ....    // init current sense   current_sense.init();   // link the current sense to the motor   motor.linkCurrentSense(&amp;current_sense);   ...   // start the FOC   motor.initFOC(); }</p> </li> </ol> <p>Info</p> <p>For instructions on incorporating the <code>InlineCurrentSense</code> class, please refer to the SimpleFOC documentation.</p>"},{"location":"troubleshooting_tips/","title":"Troubleshooting Tips","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search product forums and ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"troubleshooting_tips/#esp32-compile-error","title":"ESP32 Compile Error","text":"<p>If users run into an error similar to, <code>fatal error: soc/soc_caps.h: No such file or directory</code>, it may be due to an issue with the version of the ESP32 Arduino core that is installed in the Boards Manager. Users should make sure the have the latest version of the ESP32 Arduino core installed; or at least a version later than <code>v2.0.1</code>.</p> <p>Info</p> <p>For more information, please reference this forum post for the Simple FOC Arduino library.</p>"},{"location":"assets/board_files/","title":"board_files directory","text":"<ol> <li>A <code>dimensions*.pdf</code> file containing the board's measurements.</li> <li>A <code>schematic.pdf</code> file containing the board's schematics.</li> <li>An <code>eagle_files*.zip</code> folder containing the Eagle CAD schematics (<code>*.sch</code>) and PCB design (<code>*.brd</code>) files.<ul> <li>A freeware version of Autodesk Eagle can be found here. </li> </ul> </li> </ol>"},{"location":"assets/component_documentation/","title":"component_documentation directory","text":"<p>A copy of the datasheets, user manuals, programming guides, etc. of the major electrical components on the board.</p> <ul> <li>APA2112 Datasheet (PDF)</li> <li>APA63357 Datasheet (PDF)</li> <li>CH340C Datasheet (PDF)</li> <li>ESP32-WROOM Datasheet (PDF)</li> <li>TMC6300 Datasheet (PDF)</li> <li>TMAG5273 Datasheet (PDF)</li> <li>INA240 Datasheet (PDF)</li> <li>MCP6021 Datasheet (PDF)</li> <li>WS2812 Datasheet (PDF)</li> </ul>"},{"location":"assets/img/","title":"img directory","text":"<p>This folder should contain the images for the product documentation</p>"},{"location":"assets/img/#general-images","title":"General Images","text":"<ul> <li><code>sfe_logo_sm.png</code> - SparkFun flame logo (Cover page for with-pdf extension)</li> <li><code>sfe_logo_sq.png</code> - SparkFun flame logo (favicon)</li> </ul>"},{"location":"assets/img/#directory","title":"Directory","text":"<ul> <li><code>hookup_guide</code> - Images for the hookup guide pages</li> </ul>"},{"location":"assets/img/#qr-codes","title":"QR Codes","text":"<ul> <li>QR code generator<ul> <li>Flame Color: #E0311D</li> <li>Frame Color: #3C464D</li> </ul> </li> <li>Remove meta data from svg</li> </ul>"},{"location":"assets/img/hookup_guide/","title":"img/hookup_guide directory","text":"<p>This folder should contain the images for the hookup guide pages</p>"},{"location":"github/","title":"github directory","text":"<p>This folder should contain the instructions for submitting issues and pull requests for this project</p>"},{"location":"github/contribute/","title":"Contribute: Make an Augmentation!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"github/contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun IoT Brushless Motor Driver repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your corrections or improvements to the markdown file.</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun IoT Brushless Motor Driver repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-enhancement","title":"Submit a Design Enhancement","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to the contributors for this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. This Submit Issues page is not where users should seek assistance.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search the product forums and ask questions.</p> <p>Account Registration Required</p> <p>For your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of our documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun IoT Brushless Motor Driver repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"\ud83d\udd0d Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun IoT Brushless Motor Driver repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense? \ud83e\udd14","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board? \ud83e\udd26","text":"<p>If part of the board's functionality is missing, please open an issue and file a feature request.</p> <p>Design Considerations</p> <p>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements.</p> <ul> <li>For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"},{"location":"stylesheet/REAMDE/","title":"stylesheet directory","text":"<p>This folder should contain the files used for the webpage customizations of the product documentation</p>"}]}